; This file is autogenerated, as the compiler side needs to be updated the same way
Data.l 1045
Data$ "AAA"	;ASCII Adjust After Addition
Data$ "AAD"	;ASCII Adjust AX Before Division
Data$ "AAM"	;ASCII Adjust AX After Multiply
Data$ "AAS"	;ASCII Adjust AL After Subtraction
Data$ "ADC"	;Add With Carry
Data$ "ADCX"	;Unsigned Integer Addition of Two Operands With Carry Flag
Data$ "ADD"	;Add
Data$ "ADDPD"	;Add Packed Double-Precision Floating-Point Values
Data$ "ADDPS"	;Add Packed Single-Precision Floating-Point Values
Data$ "ADDSD"	;Add Scalar Double-Precision Floating-Point Values
Data$ "ADDSS"	;Add Scalar Single-Precision Floating-Point Values
Data$ "ADDSUBPD"	;Packed Double-FP Add/Subtract
Data$ "ADDSUBPS"	;Packed Single-FP Add/Subtract
Data$ "ADOX"	;Unsigned Integer Addition of Two Operands With Overflow Flag
Data$ "AESDEC"	;Perform One Round of an AES Decryption Flow
Data$ "AESDECLAST"	;Perform Last Round of an AES Decryption Flow
Data$ "AESENC"	;Perform One Round of an AES Encryption Flow
Data$ "AESENCLAST"	;Perform Last Round of an AES Encryption Flow
Data$ "AESIMC"	;Perform the AES InvMixColumn Transformation
Data$ "AESKEYGENASSIST"	;AES Round Key Generation Assist
Data$ "AND"	;Logical And
Data$ "ANDN"	;Logical And Not
Data$ "ANDNPD"	;Bitwise Logical And Not of Packed Double Precision Floating-Point Values
Data$ "ANDNPS"	;Bitwise Logical And Not of Packed Single Precision Floating-Point Values
Data$ "ANDPD"	;Bitwise Logical And of Packed Double Precision Floating-Point Values
Data$ "ANDPS"	;Bitwise Logical And of Packed Single Precision Floating-Point Values
Data$ "ARPL"	;Adjust RPL Field of Segment Selector
Data$ "BEXTR"	;Bit Field Extract
Data$ "BLENDPD"	;Blend Packed Double Precision Floating-Point Values
Data$ "BLENDPS"	;Blend Packed Single Precision Floating-Point Values
Data$ "BLENDVPD"	;Variable Blend Packed Double Precision Floating-Point Values
Data$ "BLENDVPS"	;Variable Blend Packed Single Precision Floating-Point Values
Data$ "BLSI"	;Extract Lowest Set Isolated Bit
Data$ "BLSMSK"	;Get Mask Up To Lowest Set Bit
Data$ "BLSR"	;Reset Lowest Set Bit
Data$ "BNDCL"	;Check Lower Bound
Data$ "BNDCN"	;Check Upper Bound
Data$ "BNDCU"	;Check Upper Bound
Data$ "BNDLDX"	;Load Extended Bounds Using Address Translation
Data$ "BNDMK"	;Make Bounds
Data$ "BNDMOV"	;Move Bounds
Data$ "BNDSTX"	;Store Extended Bounds Using Address Translation
Data$ "BOUND"	;Check Array Index Against Bounds
Data$ "BSF"	;Bit Scan Forward
Data$ "BSR"	;Bit Scan Reverse
Data$ "BSWAP"	;Byte Swap
Data$ "BT"	;Bit Test
Data$ "BTC"	;Bit Test And Complement
Data$ "BTR"	;Bit Test And Reset
Data$ "BTS"	;Bit Test And Set
Data$ "BZHI";	Zero High Bits Starting With Specified Bit Position
Data$ "CALL";	Call Procedure
Data$ "CBW"	;Convert Byte To Word/Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "CDQ"	;Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "CDQE"	;Convert Byte To Word/Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "CLAC"	;Clear AC Flag in EFLAGS Register
Data$ "CLC"	;Clear Carry Flag
Data$ "CLD"	;Clear Direction Flag
Data$ "CLDEMOTE"	;Cache Line Demote
Data$ "CLFLUSH"	;Flush Cache Line
Data$ "CLFLUSHOPT"	;Flush Cache Line Optimized
Data$ "CLI"	;Clear Interrupt Flag
Data$ "CLTS"	;Clear Task-Switched Flag in CR0
Data$ "CLWB"	;Cache Line Write Back
Data$ "CMC"	;Complement Carry Flag
Data$ "CMOVA";
Data$ "CMOVAE";
Data$ "CMOVB";
Data$ "CMOVBE";
Data$ "COMVC";
Data$ "CMOVE";
Data$ "CMOVG";
Data$ "CMOVGE";
Data$ "CMOVL"; 
Data$ "CMOVLE";
Data$ "CMOVNA";
Data$ "CMOVNAE"; 
Data$ "CMOVNB";
Data$ "CMOVNBE";
Data$ "CMOVNC";
Data$ "CMOVNE";
Data$ "CMOVNG";
Data$ "CMOVNGE";
Data$ "CMOVNL";
Data$ "CMOVNLE";
Data$ "CMOVNO";
Data$ "CMOVNP";
Data$ "CMOVNS";
Data$ "CMOVNZ";
Data$ "CMOVO";
Data$ "CMOVP";
Data$ "CMOVPE";
Data$ "CMOVPO";
Data$ "CMOVS";
Data$ "CMOVZ"; 
Data$ "CMP"; Compare Two Operands
Data$ "CMPPD"; Compare Packed Double-Precision Floating-Point Values
Data$ "CMPPS"; Compare Packed Single-Precision Floating-Point Values
Data$ "CMPS"; Compare String Operands
Data$ "CMPSB"; Compare String Operands
Data$ "CMPSD"; Compare String Operands
Data$ "CMPSQ";Compare String Operands
Data$ "CMPSS"	;Compare Scalar Single-Precision Floating-Point Value
Data$ "CMPSW"	;Compare String Operands
Data$ "CMPXCHG"	;Compare And Exchange
Data$ "CMPXCHG16B";	Compare And Exchange Bytes
Data$ "CMPXCHG8B"	;Compare And Exchange Bytes
Data$ "COMISD"	;Compare Scalar Ordered Double-Precision Floating-Point Values And Set EFLAGS
Data$ "COMISS"	;Compare Scalar Ordered Single-Precision Floating-Point Values And Set EFLAGS
Data$ "CPUID"	;CPU Identification
Data$ "CQO"	;Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "CRC32"	;Accumulate CRC32 Value
Data$ "CVTDQ2PD"	;Convert Packed Doubleword Integers To Packed Double-Precision Floating-Point Values
Data$ "CVTDQ2PS"	;Convert Packed Doubleword Integers To Packed Single-Precision Floating-Point Values
Data$ "CVTPD2DQ"	;Convert Packed Double-Precision Floating-Point Values To Packed Doubleword Integers
Data$ "CVTPD2PI"	;Convert Packed Double-Precision FP Values To Packed Dword Integers
Data$ "CVTPD2PS"	;Convert Packed Double-Precision Floating-Point Values To Packed Single-Precision Floating-Point Values
Data$ "CVTPI2PD"	;Convert Packed Dword Integers To Packed Double-Precision FP Values
Data$ "CVTPI2PS"	;Convert Packed Dword Integers To Packed Single-Precision FP Values
Data$ "CVTPS2DQ"	;Convert Packed Single-Precision Floating-Point Values To Packed Signed Doubleword Integer Values
Data$ "CVTPS2PD"	;Convert Packed Single-Precision Floating-Point Values To Packed Double-Precision Floating-Point Values
Data$ "CVTPS2PI"	;Convert Packed Single-Precision FP Values To Packed Dword Integers
Data$ "CVTSD2SI"	;Convert Scalar Double-Precision Floating-Point Value To Doubleword Integer
Data$ "CVTSD2SS"	;Convert Scalar Double-Precision Floating-Point Value To Scalar Single-Precision Floating-Point Value
Data$ "CVTSI2SD"	;Convert Doubleword Integer To Scalar Double-Precision Floating-Point Value
Data$ "CVTSI2SS"	;Convert Doubleword Integer To Scalar Single-Precision Floating-Point Value
Data$ "CVTSS2SD"	;Convert Scalar Single-Precision Floating-Point Value To Scalar Double-Precision Floating-Point Value
Data$ "CVTSS2SI"	;Convert Scalar Single-Precision Floating-Point Value To Doubleword Integer
Data$ "CVTTPD2DQ"	;Convert With Truncation Packed Double-Precision Floating-Point Values To Packed Doubleword Integers
Data$ "CVTTPD2PI"	;Convert With Truncation Packed Double-Precision FP Values To Packed Dword Integers
Data$ "CVTTPS2DQ"	;Convert With Truncation Packed Single-Precision Floating-Point Values To Packed Signed Doubleword Integer Values
Data$ "CVTTPS2PI"	;Convert With Truncation Packed Single-Precision FP Values To Packed Dword Integers
Data$ "CVTTSD2SI"	;Convert With Truncation Scalar Double-Precision Floating-Point Value To Signed Integer
Data$ "CVTTSS2SI"	;Convert With Truncation Scalar Single-Precision Floating-Point Value To Integer
Data$ "CWD"	;Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "CWDE"	;Convert Byte To Word/Convert Word To Doubleword/Convert Doubleword To Quadword
Data$ "DAA"	;Decimal Adjust AL after Addition
Data$ "DAS"	;Decimal Adjust AL after Subtraction
Data$ "DEC"	;Decrement by 1
Data$ "DIV"	;Unsigned Divide
Data$ "DIVPD";	Divide Packed Double-Precision Floating-Point Values
Data$ "DIVPS"	;Divide Packed Single-Precision Floating-Point Values
Data$ "DIVSD"	;Divide Scalar Double-Precision Floating-Point Value
Data$ "DIVSS"	;Divide Scalar Single-Precision Floating-Point Values
Data$ "DPPD"	;Dot Product of Packed Double Precision Floating-Point Values
Data$ "DPPS"	;Dot Product of Packed Single Precision Floating-Point Values
Data$ "EMMS"	;Empty MMX Technology State
Data$ "ENTER"	;Make Stack Frame For Procedure Parameters
Data$ "EXTRACTPS";	Extract Packed Floating-Point Values
Data$ "F2XM1";	Compute 2x–1
Data$ "FABS";	Absolute Value
Data$ "FADD";	Add
Data$ "FADDP";	Add
Data$ "FBLD";	Load Binary Coded Decimal
Data$ "FBSTP";	Store BCD Integer And Pop
Data$ "FCHS";	Change Sign
Data$ "FCLEX";	Clear Exceptions
Data$ "FCMOVB"
Data$ "FCMOVE"
Data$ "FCMOVBE"
Data$ "FCMOVU"
Data$ "FCMOVNB"
Data$ "FCMOVNE"
Data$ "FCMOVNBE"
Data$ "FCMOVNU"
Data$ "FCOM";	Compare Floating Point Values
Data$ "FCOMI";	Compare Floating Point Values And Set EFLAGS
Data$ "FCOMIP";	Compare Floating Point Values And Set EFLAGS
Data$ "FCOMP"	;Compare Floating Point Values
Data$ "FCOMPP";	Compare Floating Point Values
Data$ "FCOS";	Cosine
Data$ "FDECSTP";	Decrement Stack-Top Pointer
Data$ "FDIV";	Divide
Data$ "FDIVP";	Divide
Data$ "FDIVR";	Reverse Divide
Data$ "FDIVRP";	Reverse Divide
Data$ "FFREE";	Free Floating-Point Register
Data$ "FIADD";	Add
Data$ "FICOM";	Compare Integer
Data$ "FICOMP";	Compare Integer
Data$ "FIDIV";	Divide
Data$ "FIDIVR";	Reverse Divide
Data$ "FILD";	Load Integer
Data$ "FIMUL";	Multiply
Data$ "FINCSTP";	Increment Stack-Top Pointer
Data$ "FINIT";	Initialize Floating-Point Unit
Data$ "FIST";	Store Integer
Data$ "FISTP";	Store Integer
Data$ "FISTTP";	Store Integer With Truncation
Data$ "FISUB";	Subtract
Data$ "FISUBR";	Reverse Subtract
Data$ "FLD";	Load Floating Point Value
Data$ "FLD1";	Load Constant
Data$ "FLDCW";	Load x87 FPU Control Word
Data$ "FLDENV";	Load x87 FPU Environment
Data$ "FLDL2E";	Load Constant
Data$ "FLDL2T";	Load Constant
Data$ "FLDLG2";	Load Constant
Data$ "FLDLN2";	Load Constant
Data$ "FLDPI";	Load Constant
Data$ "FLDZ";	Load Constant
Data$ "FMUL";	Multiply
Data$ "FMULP";	Multiply
Data$ "FNCLEX";	Clear Exceptions
Data$ "FNINIT";	Initialize Floating-Point Unit
Data$ "FNOP";	No Operation
Data$ "FNSAVE";	Store x87 FPU State
Data$ "FNSTCW";	Store x87 FPU Control Word
Data$ "FNSTENV";	Store x87 FPU Environment
Data$ "FNSTSW";	Store x87 FPU Status Word
Data$ "FPATAN";	Partial Arctangent
Data$ "FPREM";	Partial Remainder
Data$ "FPREM1";	Partial Remainder
Data$ "FPTAN";	Partial Tangent
Data$ "FRNDINT";	Round To Integer
Data$ "FRSTOR";	Restore x87 FPU State
Data$ "FSAVE";	Store x87 FPU State
Data$ "FSCALE";	Scale
Data$ "FSIN";	Sine
Data$ "FSINCOS";	Sine And Cosine
Data$ "FSQRT";	Square Root
Data$ "FST";	Store Floating Point Value
Data$ "FSTCW";	Store x87 FPU Control Word
Data$ "FSTENV";	Store x87 FPU Environment
Data$ "FSTP";	Store Floating Point Value
Data$ "FSTSW";	Store x87 FPU Status Word
Data$ "FSUB";	Subtract
Data$ "FSUBP";	Subtract
Data$ "FSUBR";	Reverse Subtract
Data$ "FSUBRP";	Reverse Subtract
Data$ "FTST";	TEST
Data$ "FUCOM";	Unordered Compare Floating Point Values
Data$ "FUCOMI";	Compare Floating Point Values And Set EFLAGS
Data$ "FUCOMIP";	Compare Floating Point Values And Set EFLAGS
Data$ "FUCOMP";	Unordered Compare Floating Point Values
Data$ "FUCOMPP";	Unordered Compare Floating Point Values
Data$ "FWAIT";	Wait
Data$ "FXAM";	Examine Floating-Point
Data$ "FXCH";	Exchange Register Contents
Data$ "FXRSTOR";	Restore x87 FPU, MMX, XMM, And MXCSR State
Data$ "FXSAVE";	Save x87 FPU, MMX Technology, And SSE State
Data$ "FXTRACT";	Extract Exponent And Significand
Data$ "FYL2X";	Compute y ∗ log2x
Data$ "FYL2XP1";	Compute y ∗ log2(x +1)
Data$ "GF2P8AFFINEINVQB";	Galois Field Affine Transformation Inverse
Data$ "GF2P8AFFINEQB";	Galois Field Affine Transformation
Data$ "GF2P8MULB";	Galois Field Multiply Bytes
Data$ "HADDPD";	Packed Double-FP Horizontal Add
Data$ "HADDPS";	Packed Single-FP Horizontal Add
Data$ "HLT";	Halt
Data$ "HSUBPD";	Packed Double-FP Horizontal Subtract
Data$ "HSUBPS";	Packed Single-FP Horizontal Subtract
Data$ "IDIV";	Signed Divide
Data$ "IMUL";	Signed Multiply
Data$ "IN";	Input from Port
Data$ "INC";	Increment by 1
Data$ "INS";	Input from Port To String
Data$ "INSB";	Input from Port To String
Data$ "INSD";	Input from Port To String
Data$ "INSERTPS";	Insert Scalar Single-Precision Floating-Point Value
Data$ "INSW";	Input from Port To String
Data$ "INT"; n	Call To Interrupt Procedure
Data$ "INT1";	Call To Interrupt Procedure
Data$ "INT3";	Call To Interrupt Procedure
Data$ "INTO";	Call To Interrupt Procedure
Data$ "INVD";	Invalidate Internal Caches
Data$ "INVLPG";	Invalidate TLB Entries
Data$ "INVPCID";	Invalidate Process-Context Identifier
Data$ "IRET";	Interrupt Return
Data$ "IRETD";	Interrupt Return
Data$ "JMP";	Jump
Data$ "JA"
Data$ "JAE"
Data$ "JB"
Data$ "JBE"
Data$ "JC"
Data$ "JCXZ"
Data$ "JECXZ"
Data$ "JRCXZ"
Data$ "JE"
Data$ "JG"
Data$ "JGE"
Data$ "JL"
Data$ "JLE"
Data$ "JNA"
Data$ "JNAE"
Data$ "JNB"
Data$ "JNBE"
Data$ "JNC"
Data$ "JNE"
Data$ "JNG"
Data$ "JNGE"
Data$ "JNL"
Data$ "JNLE"
Data$ "JNO"
Data$ "JNP"
Data$ "JNS"
Data$ "JNZ"
Data$ "JO"
Data$ "JP"
Data$ "JPE"
Data$ "JPO"
Data$ "JS"
Data$ "JZ"
Data$ "KADDB";	ADD Two Masks
Data$ "KADDD";	ADD Two Masks
Data$ "KADDQ";	ADD Two Masks
Data$ "KADDW";	ADD Two Masks
Data$ "KANDB";	Bitwise Logical And Masks
Data$ "KANDD";	Bitwise Logical And Masks
Data$ "KANDNB";	Bitwise Logical And Not Masks
Data$ "KANDND";	Bitwise Logical And Not Masks
Data$ "KANDNQ";	Bitwise Logical And Not Masks
Data$ "KANDNW";	Bitwise Logical And Not Masks
Data$ "KANDQ"	;Bitwise Logical And Masks
Data$ "KANDW"	;Bitwise Logical And Masks
Data$ "KMOVB"	;Move from And To Mask Registers
Data$ "KMOVD"	;Move from And To Mask Registers
Data$ "KMOVQ"	;Move from And To Mask Registers
Data$ "KMOVW"	;Move from And To Mask Registers
Data$ "KNOTB"	;Not Mask Register
Data$ "KNOTD"	;Not Mask Register
Data$ "KNOTQ"	;Not Mask Register
Data$ "KNOTW"	;Not Mask Register
Data$ "KORB"	;Bitwise Logical Or Masks
Data$ "KORD"	;Bitwise Logical Or Masks
Data$ "KORQ"	;Bitwise Logical Or Masks
Data$ "KORTESTB";	Or Masks And Set Flags
Data$ "KORTESTD";	Or Masks And Set Flags
Data$ "KORTESTQ";	Or Masks And Set Flags
Data$ "KORTESTW";	Or Masks And Set Flags
Data$ "KORW";	Bitwise Logical Or Masks
Data$ "KSHIFTLB";	Shift Left Mask Registers
Data$ "KSHIFTLD";	Shift Left Mask Registers
Data$ "KSHIFTLQ";	Shift Left Mask Registers
Data$ "KSHIFTLW";	Shift Left Mask Registers
Data$ "KSHIFTRB";	Shift Right Mask Registers
Data$ "KSHIFTRD";	Shift Right Mask Registers
Data$ "KSHIFTRQ";	Shift Right Mask Registers
Data$ "KSHIFTRW";	Shift Right Mask Registers
Data$ "KTESTB";	Packed Bit Test Masks And Set Flags
Data$ "KTESTD";	Packed Bit Test Masks And Set Flags
Data$ "KTESTQ";	Packed Bit Test Masks And Set Flags
Data$ "KTESTW";	Packed Bit Test Masks And Set Flags
Data$ "KUNPCKBW";	Unpack For Mask Registers
Data$ "KUNPCKDQ";	Unpack For Mask Registers
Data$ "KUNPCKWD";	Unpack For Mask Registers
Data$ "KXNORB";	Bitwise Logical XNOR Masks
Data$ "KXNORD";	Bitwise Logical XNOR Masks
Data$ "KXNORQ";	Bitwise Logical XNOR Masks
Data$ "KXNORW";	Bitwise Logical XNOR Masks
Data$ "KXORB";	Bitwise Logical XOr Masks
Data$ "KXORD";	Bitwise Logical XOr Masks
Data$ "KXORQ";	Bitwise Logical XOr Masks
Data$ "KXORW";	Bitwise Logical XOr Masks
Data$ "LAHF";	Load Status Flags into AH Register
Data$ "LAR";	Load Access Rights Byte
Data$ "LDDQU";	Load Unaligned Integer 128 Bits
Data$ "LDMXCSR";	Load MXCSR Register
Data$ "LDS";	Load Far Pointer
Data$ "LEA";	Load Effective Address
Data$ "LEAVE";	High Level Procedure Exit
Data$ "LES";	Load Far Pointer
Data$ "LFENCE";	Load Fence
Data$ "LFS";	Load Far Pointer
Data$ "LGDT";	Load Global/Interrupt Descriptor Table Register
Data$ "LGS";	Load Far Pointer
Data$ "LIDT";	Load Global/Interrupt Descriptor Table Register
Data$ "LLDT";	Load Local Descriptor Table Register
Data$ "LMSW";	Load Machine Status Word
Data$ "LOCK";	Assert LOCK# Signal Prefix
Data$ "LODS";	Load String
Data$ "LODSB";	Load String
Data$ "LODSD";	Load String
Data$ "LODSQ";	Load String
Data$ "LODSW";	Load String
Data$ "LOOP";	Loop According To ECX Counter
Data$ "LOOPE";
Data$ "LOOPNE"
Data$ "LSL";	Load Segment Limit
Data$ "LSS";	Load Far Pointer
Data$ "LTR";	Load Task Register
Data$ "LZCNT";	Count the Number of Leading Zero Bits
Data$ "MASKMOVDQU";	Store Selected Bytes of Double Quadword
Data$ "MASKMOVQ";	Store Selected Bytes of Quadword
Data$ "MAXPD";	Maximum of Packed Double-Precision Floating-Point Values
Data$ "MAXPS";	Maximum of Packed Single-Precision Floating-Point Values
Data$ "MAXSD";	Return Maximum Scalar Double-Precision Floating-Point Value
Data$ "MAXSS";	Return Maximum Scalar Single-Precision Floating-Point Value
Data$ "MFENCE";	Memory Fence
Data$ "MINPD";	Minimum of Packed Double-Precision Floating-Point Values
Data$ "MINPS";	Minimum of Packed Single-Precision Floating-Point Values
Data$ "MINSD";	Return Minimum Scalar Double-Precision Floating-Point Value
Data$ "MINSS";	Return Minimum Scalar Single-Precision Floating-Point Value
Data$ "MONITOR";	Set Up Monitor Address
Data$ "MOV";	Move
Data$ "MOVAPD";	Move Aligned Packed Double-Precision Floating-Point Values
Data$ "MOVAPS";	Move Aligned Packed Single-Precision Floating-Point Values
Data$ "MOVBE";	Move Data After Swapping Bytes
Data$ "MOVD";	Move Doubleword/Move Quadword
Data$ "MOVDDUP";	Replicate Double FP Values
Data$ "MOVDIR64B";	Move 64 Bytes As Direct Store
Data$ "MOVDIRI";	Move Doubleword As Direct Store
Data$ "MOVDQ2Q";	Move Quadword from XMM To MMX Technology Register
Data$ "MOVDQA";	Move Aligned Packed Integer Values
Data$ "MOVDQU";	Move Unaligned Packed Integer Values
Data$ "MOVHLPS";	Move Packed Single-Precision Floating-Point Values High To Low
Data$ "MOVHPD";	Move High Packed Double-Precision Floating-Point Value
Data$ "MOVHPS";	Move High Packed Single-Precision Floating-Point Values
Data$ "MOVLHPS";	Move Packed Single-Precision Floating-Point Values Low To High
Data$ "MOVLPD";	Move Low Packed Double-Precision Floating-Point Value
Data$ "MOVLPS";	Move Low Packed Single-Precision Floating-Point Values
Data$ "MOVMSKPD";	Extract Packed Double-Precision Floating-Point Sign Mask
Data$ "MOVMSKPS";	Extract Packed Single-Precision Floating-Point Sign Mask
Data$ "MOVNTDQ";	Store Packed Integers Using Non-Temporal Hint
Data$ "MOVNTDQA";	Load Double Quadword Non-Temporal Aligned Hint
Data$ "MOVNTI";	Store Doubleword Using Non-Temporal Hint
Data$ "MOVNTPD";	Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint
Data$ "MOVNTPS";	Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint
Data$ "MOVNTQ";	Store of Quadword Using Non-Temporal Hint
Data$ "MOVQ";	Move Doubleword/Move Quadword
Data$ "MOVQ2DQ";	Move Quadword from MMX Technology To XMM Register
Data$ "MOVS";	Move Data from String To String
Data$ "MOVSB";	Move Data from String To String
Data$ "MOVSD";	Move Data from String To String
Data$ "MOVSHDUP";	Replicate Single FP Values
Data$ "MOVSLDUP";	Replicate Single FP Values
Data$ "MOVSQ";	Move Data from String To String
Data$ "MOVSS";	Move Or Merge Scalar Single-Precision Floating-Point Value
Data$ "MOVSW";	Move Data from String To String
Data$ "MOVSX";	Move With Sign-Extension
Data$ "MOVSXD";	Move With Sign-Extension
Data$ "MOVUPD";	Move Unaligned Packed Double-Precision Floating-Point Values
Data$ "MOVUPS";	Move Unaligned Packed Single-Precision Floating-Point Values
Data$ "MOVZX";	Move With Zero-Extend
Data$ "MPSADBW";	Compute Multiple Packed Sums of Absolute Difference
Data$ "MUL";	Unsigned Multiply
Data$ "MULPD";	Multiply Packed Double-Precision Floating-Point Values
Data$ "MULPS";	Multiply Packed Single-Precision Floating-Point Values
Data$ "MULSD";	Multiply Scalar Double-Precision Floating-Point Value
Data$ "MULSS";	Multiply Scalar Single-Precision Floating-Point Values
Data$ "MULX";	Unsigned Multiply Without Affecting Flags
Data$ "MWAIT";	Monitor Wait
Data$ "NEG";	Two's Complement Negation
Data$ "NOP";	No Operation
Data$ "NOT";	One's Complement Negation
Data$ "OR";	Logical Inclusive Or
Data$ "ORPD";	Bitwise Logical Or of Packed Double Precision Floating-Point Values
Data$ "ORPS";	Bitwise Logical Or of Packed Single Precision Floating-Point Values
Data$ "OUT";	Output To Port
Data$ "OUTS";	Output String To Port
Data$ "OUTSB";	Output String To Port
Data$ "OUTSD";	Output String To Port
Data$ "OUTSW";	Output String To Port
Data$ "PABSB";	Packed Absolute Value
Data$ "PABSD";	Packed Absolute Value
Data$ "PABSQ";	Packed Absolute Value
Data$ "PABSW";	Packed Absolute Value
Data$ "PACKSSDW";	Pack With Signed Saturation
Data$ "PACKSSWB";	Pack With Signed Saturation
Data$ "PACKUSDW";	Pack With Unsigned Saturation
Data$ "PACKUSWB";	Pack With Unsigned Saturation
Data$ "PADDB";	Add Packed Integers
Data$ "PADDD";	Add Packed Integers
Data$ "PADDQ";	Add Packed Integers
Data$ "PADDSB";	Add Packed Signed Integers With Signed Saturation
Data$ "PADDSW";	Add Packed Signed Integers With Signed Saturation
Data$ "PADDUSB";	Add Packed Unsigned Integers With Unsigned Saturation
Data$ "PADDUSW";	Add Packed Unsigned Integers With Unsigned Saturation
Data$ "PADDW";	Add Packed Integers
Data$ "PALIGNR";	Packed Align Right
Data$ "PAND";	Logical And
Data$ "PANDN";	Logical And Not
Data$ "PAUSE";	Spin Loop Hint
Data$ "PAVGB";	Average Packed Integers
Data$ "PAVGW";	Average Packed Integers
Data$ "PBLENDVB";	Variable Blend Packed Bytes
Data$ "PBLENDW";	Blend Packed Words
Data$ "PCLMULQDQ";	Carry-Less Multiplication Quadword
Data$ "PCMPEQB";	Compare Packed Data For Equal
Data$ "PCMPEQD";	Compare Packed Data For Equal
Data$ "PCMPEQQ";	Compare Packed Qword Data For Equal
Data$ "PCMPEQW";	Compare Packed Data For Equal
Data$ "PCMPESTRI";	Packed Compare Explicit Length Strings, Return Index
Data$ "PCMPESTRM";	Packed Compare Explicit Length Strings, Return Mask
Data$ "PCMPGTB";	Compare Packed Signed Integers For Greater Than
Data$ "PCMPGTD";	Compare Packed Signed Integers For Greater Than
Data$ "PCMPGTQ";	Compare Packed Data For Greater Than
Data$ "PCMPGTW";	Compare Packed Signed Integers For Greater Than
Data$ "PCMPISTRI";	Packed Compare Implicit Length Strings, Return Index
Data$ "PCMPISTRM";	Packed Compare Implicit Length Strings, Return Mask
Data$ "PDEP";	Parallel Bits Deposit
Data$ "PEXT";	Parallel Bits Extract
Data$ "PEXTRB";	Extract Byte/Dword/Qword
Data$ "PEXTRD";	Extract Byte/Dword/Qword
Data$ "PEXTRQ";	Extract Byte/Dword/Qword
Data$ "PEXTRW";	Extract Word
Data$ "PHADDD";	Packed Horizontal Add
Data$ "PHADDSW";	Packed Horizontal Add And Saturate
Data$ "PHADDW";	Packed Horizontal Add
Data$ "PHMINPOSUW";	Packed Horizontal Word Minimum
Data$ "PHSUBD";	Packed Horizontal Subtract
Data$ "PHSUBSW";	Packed Horizontal Subtract And Saturate
Data$ "PHSUBW";	Packed Horizontal Subtract
Data$ "PINSRB";	Insert Byte/Dword/Qword
Data$ "PINSRD";	Insert Byte/Dword/Qword
Data$ "PINSRQ";	Insert Byte/Dword/Qword
Data$ "PINSRW";	Insert Word
Data$ "PMADDUBSW";	Multiply And Add Packed Signed And Unsigned Bytes
Data$ "PMADDWD";	Multiply And Add Packed Integers
Data$ "PMAXSB";	Maximum of Packed Signed Integers
Data$ "PMAXSD";	Maximum of Packed Signed Integers
Data$ "PMAXSQ";	Maximum of Packed Signed Integers
Data$ "PMAXSW";	Maximum of Packed Signed Integers
Data$ "PMAXUB";	Maximum of Packed Unsigned Integers
Data$ "PMAXUD";	Maximum of Packed Unsigned Integers
Data$ "PMAXUQ";	Maximum of Packed Unsigned Integers
Data$ "PMAXUW";	Maximum of Packed Unsigned Integers
Data$ "PMINSB";	Minimum of Packed Signed Integers
Data$ "PMINSD";	Minimum of Packed Signed Integers
Data$ "PMINSQ";	Minimum of Packed Signed Integers
Data$ "PMINSW";	Minimum of Packed Signed Integers
Data$ "PMINUB";	Minimum of Packed Unsigned Integers
Data$ "PMINUD";	Minimum of Packed Unsigned Integers
Data$ "PMINUQ";	Minimum of Packed Unsigned Integers
Data$ "PMINUW";	Minimum of Packed Unsigned Integers
Data$ "PMOVMSKB";	Move Byte Mask
Data$ "PMOVSX";	Packed Move With Sign Extend
Data$ "PMOVZX";	Packed Move With Zero Extend
Data$ "PMULDQ";	Multiply Packed Doubleword Integers
Data$ "PMULHRSW";	Packed Multiply High With Round And Scale
Data$ "PMULHUW";	Multiply Packed Unsigned Integers And Store High Result
Data$ "PMULHW";	Multiply Packed Signed Integers And Store High Result
Data$ "PMULLD";	Multiply Packed Integers And Store Low Result
Data$ "PMULLQ";	Multiply Packed Integers And Store Low Result
Data$ "PMULLW";	Multiply Packed Signed Integers And Store Low Result
Data$ "PMULUDQ";	Multiply Packed Unsigned Doubleword Integers
Data$ "POP";	Pop a Value from the Stack
Data$ "POPA";	Pop All General-Purpose Registers
Data$ "POPAD";	Pop All General-Purpose Registers
Data$ "POPCNT";	Return the Count of Number of Bits Set To 1
Data$ "POPF";	Pop Stack into EFLAGS Register
Data$ "POPFD";	Pop Stack into EFLAGS Register
Data$ "POPFQ";	Pop Stack into EFLAGS Register
Data$ "POR";	Bitwise Logical Or
Data$ "PREFETCHW";	Prefetch Data into Caches in Anticipation of a Write
Data$ "PREFETCH0";	Prefetch Data Into Caches
Data$ "PREFETCH1"
Data$ "PREFETCH2"
Data$ "PREFETCHNTA"
Data$ "PSADBW";	Compute Sum of Absolute Differences
Data$ "PSHUFB";	Packed Shuffle Bytes
Data$ "PSHUFD";	Shuffle Packed Doublewords
Data$ "PSHUFHW";	Shuffle Packed High Words
Data$ "PSHUFLW";	Shuffle Packed Low Words
Data$ "PSHUFW";	Shuffle Packed Words
Data$ "PSIGNB";	Packed SIGN
Data$ "PSIGND";	Packed SIGN
Data$ "PSIGNW";	Packed SIGN
Data$ "PSLLD"	;Shift Packed Data Left Logical
Data$ "PSLLDQ";	Shift Double Quadword Left Logical
Data$ "PSLLQ";	Shift Packed Data Left Logical
Data$ "PSLLW";	Shift Packed Data Left Logical
Data$ "PSRAD";	Shift Packed Data Right Arithmetic
Data$ "PSRAQ";	Shift Packed Data Right Arithmetic
Data$ "PSRAW";	Shift Packed Data Right Arithmetic
Data$ "PSRLD";	Shift Packed Data Right Logical
Data$ "PSRLDQ";	Shift Double Quadword Right Logical
Data$ "PSRLQ";	Shift Packed Data Right Logical
Data$ "PSRLW";	Shift Packed Data Right Logical
Data$ "PSUBB";	Subtract Packed Integers
Data$ "PSUBD";	Subtract Packed Integers
Data$ "PSUBQ";	Subtract Packed Quadword Integers
Data$ "PSUBSB";	Subtract Packed Signed Integers With Signed Saturation
Data$ "PSUBSW";	Subtract Packed Signed Integers With Signed Saturation
Data$ "PSUBUSB";	Subtract Packed Unsigned Integers With Unsigned Saturation
Data$ "PSUBUSW";	Subtract Packed Unsigned Integers With Unsigned Saturation
Data$ "PSUBW";	Subtract Packed Integers
Data$ "PTEST";	Logical Compare
Data$ "PTWRITE";	Write Data To a Processor Trace Packet
Data$ "PUNPCKHBW";	Unpack High Data
Data$ "PUNPCKHDQ";	Unpack High Data
Data$ "PUNPCKHQDQ";	Unpack High Data
Data$ "PUNPCKHWD";	Unpack High Data
Data$ "PUNPCKLBW";	Unpack Low Data
Data$ "PUNPCKLDQ";	Unpack Low Data
Data$ "PUNPCKLQDQ";	Unpack Low Data
Data$ "PUNPCKLWD";	Unpack Low Data
Data$ "PUSH";	Push Word, Doubleword Or Quadword Onto the Stack
Data$ "PUSHA";	Push All General-Purpose Registers
Data$ "PUSHAD";	Push All General-Purpose Registers
Data$ "PUSHF";	Push EFLAGS Register onto the Stack
Data$ "PUSHFD";	Push EFLAGS Register onto the Stack
Data$ "PUSHFQ";	Push EFLAGS Register onto the Stack
Data$ "PXOR";	Logical Exclusive Or
Data$ "RCL";	Rotate
Data$ "RCPPS";	Compute Reciprocals of Packed Single-Precision Floating-Point Values
Data$ "RCPSS";	Compute Reciprocal of Scalar Single-Precision Floating-Point Values
Data$ "RCR";	Rotate
Data$ "RDFSBASE";	Read FS/GS Segment Base
Data$ "RDGSBASE";	Read FS/GS Segment Base
Data$ "RDMSR";	Read from Model Specific Register
Data$ "RDPID";	Read Processor ID
Data$ "RDPKRU";	Read Protection Key Rights For User Pages
Data$ "RDPMC";	Read Performance-Monitoring Counters
Data$ "RDRAND";	Read Random Number
Data$ "RDSEED";	Read Random SEED
Data$ "RDTSC";	Read Time-Stamp Counter
Data$ "RDTSCP";	Read Time-Stamp Counter And Processor ID
Data$ "REP";	Repeat String Operation Prefix
Data$ "REPE";	Repeat String Operation Prefix
Data$ "REPNE";	Repeat String Operation Prefix
Data$ "REPNZ";	Repeat String Operation Prefix
Data$ "REPZ";	Repeat String Operation Prefix
Data$ "RET";	Return from Procedure
Data$ "ROL";	Rotate
Data$ "ROR";	Rotate
Data$ "RORX";	Rotate Right Logical Without Affecting Flags
Data$ "ROUNDPD";	Round Packed Double Precision Floating-Point Values
Data$ "ROUNDPS";	Round Packed Single Precision Floating-Point Values
Data$ "ROUNDSD";	Round Scalar Double Precision Floating-Point Values
Data$ "ROUNDSS";	Round Scalar Single Precision Floating-Point Values
Data$ "RSM";	Resume from System Management Mode
Data$ "RSQRTPS";	Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values
Data$ "RSQRTSS";	Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value
Data$ "SAHF";	Store AH into Flags
Data$ "SAL";	Shift
Data$ "SAR";	Shift
Data$ "SARX";	Shift Without Affecting Flags
Data$ "SBB";	Integer Subtraction With Borrow
Data$ "SCAS";	Scan String
Data$ "SCASB";	Scan String
Data$ "SCASD";	Scan String
Data$ "SCASW";	Scan String
Data$ "SETA";	Set Byte on Condition
Data$ "SETAE"
Data$ "SETB"
Data$ "SETBE"
Data$ "SETC"
Data$ "SETE"
Data$ "SETG"
Data$ "SETGE"
Data$ "SETL"
Data$ "SETLE"
Data$ "SETNA"
Data$ "SETNAE"
Data$ "SETNB"
Data$ "SETNC"
Data$ "SETNE"
Data$ "SETNG"
Data$ "SETNGE"
Data$ "SETNL"
Data$ "SETNLE"
Data$ "SETNO"
Data$ "SETNP"
Data$ "SETNS"
Data$ "SETNZ"
Data$ "SETO"
Data$ "SETP"
Data$ "SETPE"
Data$ "SETPO"
Data$ "SETS"
Data$ "SETZ"
Data$ "SFENCE";	Store Fence
Data$ "SGDT";	Store Global Descriptor Table Register
Data$ "SHA1MSG1";	Perform an Intermediate Calculation For the Next Four SHA1 Message Dwords
Data$ "SHA1MSG2";	Perform a Final Calculation For the Next Four SHA1 Message Dwords
Data$ "SHA1NEXTE";	Calculate SHA1 State Variable E after Four Rounds
Data$ "SHA1RNDS4";	Perform Four Rounds of SHA1 Operation
Data$ "SHA256MSG1";	Perform an Intermediate Calculation For the Next Four SHA256 Message Dwords
Data$ "SHA256MSG2";	Perform a Final Calculation For the Next Four SHA256 Message Dwords
Data$ "SHA256RNDS2";	Perform Two Rounds of SHA256 Operation
Data$ "SHL";	Shift;
Data$ "SHLD";	Double Precision Shift Left
Data$ "SHLX";	Shift Without Affecting Flags
Data$ "SHR";	Shift
Data$ "SHRD";	Double Precision Shift Right
Data$ "SHRX";	Shift Without Affecting Flags
Data$ "SHUFPD";	Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values
Data$ "SHUFPS";	Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values
Data$ "SIDT";	Store Interrupt Descriptor Table Register
Data$ "SLDT";	Store Local Descriptor Table Register
Data$ "SMSW";	Store Machine Status Word
Data$ "SQRTPD";	Square Root of Double-Precision Floating-Point Values
Data$ "SQRTPS";	Square Root of Single-Precision Floating-Point Values
Data$ "SQRTSD";	Compute Square Root of Scalar Double-Precision Floating-Point Value
Data$ "SQRTSS";	Compute Square Root of Scalar Single-Precision Value
Data$ "STAC";	Set AC Flag in EFLAGS Register
Data$ "STC";	Set Carry Flag
Data$ "STD";	Set Direction Flag
Data$ "STI";	Set Interrupt Flag
Data$ "STMXCSR";	Store MXCSR Register State
Data$ "STOS";	Store String
Data$ "STOSB";	Store String
Data$ "STOSD";	Store String
Data$ "STOSQ";	Store String
Data$ "STOSW";	Store String
Data$ "STR";	Store Task Register
Data$ "SUB";	Subtract
Data$ "SUBPD";	Subtract Packed Double-Precision Floating-Point Values
Data$ "SUBPS";	Subtract Packed Single-Precision Floating-Point Values
Data$ "SUBSD";	Subtract Scalar Double-Precision Floating-Point Value
Data$ "SUBSS";	Subtract Scalar Single-Precision Floating-Point Value
Data$ "SWAPGS";	Swap GS Base Register
Data$ "SYSCALL";	Fast System Call
Data$ "SYSENTER";	Fast System Call
Data$ "SYSEXIT";	Fast Return from Fast System Call
Data$ "SYSRET";	Return From Fast System Call
Data$ "TEST";	Logical Compare
Data$ "TPAUSE";	Timed PAUSE
Data$ "TZCNT";	Count the Number of Trailing Zero Bits
Data$ "UCOMISD";	Unordered Compare Scalar Double-Precision Floating-Point Values And Set EFLAGS
Data$ "UCOMISS";	Unordered Compare Scalar Single-Precision Floating-Point Values And Set EFLAGS
Data$ "UD";	Undefined Instruction
Data$ "UMONITOR";	User Level Set Up Monitor Address
Data$ "UMWAIT";	User Level Monitor Wait
Data$ "UNPCKHPD";	Unpack And Interleave High Packed Double-Precision Floating-Point Values
Data$ "UNPCKHPS";	Unpack And Interleave High Packed Single-Precision Floating-Point Values
Data$ "UNPCKLPD";	Unpack And Interleave Low Packed Double-Precision Floating-Point Values
Data$ "UNPCKLPS";	Unpack And Interleave Low Packed Single-Precision Floating-Point Values
Data$ "VALIGND";	Align Doubleword/Quadword Vectors
Data$ "VALIGNQ";	Align Doubleword/Quadword Vectors
Data$ "VBLENDMPD";	Blend Float64/Float32 Vectors Using an OpMask Control
Data$ "VBLENDMPS";	Blend Float64/Float32 Vectors Using an OpMask Control
Data$ "VBROADCAST";	Load With Broadcast Floating-Point Data
Data$ "VCOMPRESSPD";	Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory
Data$ "VCOMPRESSPS";	Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory
Data$ "VCVTPD2QQ";	Convert Packed Double-Precision Floating-Point Values To Packed Quadword Integers
Data$ "VCVTPD2UDQ";	Convert Packed Double-Precision Floating-Point Values To Packed Unsigned Doubleword Integers
Data$ "VCVTPD2UQQ";	Convert Packed Double-Precision Floating-Point Values To Packed Unsigned Quadword Integers
Data$ "VCVTPH2PS";	Convert 16-bit FP values To Single-Precision FP values
Data$ "VCVTPS2PH";	Convert Single-Precision FP value To 16-bit FP value
Data$ "VCVTPS2QQ";	Convert Packed Single Precision Floating-Point Values To Packed Singed Quadword Integer Values
Data$ "VCVTPS2UDQ";	Convert Packed Single-Precision Floating-Point Values To Packed Unsigned Doubleword Integer Values
Data$ "VCVTPS2UQQ";	Convert Packed Single Precision Floating-Point Values To Packed Unsigned Quadword Integer Values
Data$ "VCVTQQ2PD";	Convert Packed Quadword Integers To Packed Double-Precision Floating-Point Values
Data$ "VCVTQQ2PS";	Convert Packed Quadword Integers To Packed Single-Precision Floating-Point Values
Data$ "VCVTSD2USI";	Convert Scalar Double-Precision Floating-Point Value To Unsigned Doubleword Integer
Data$ "VCVTSS2USI";	Convert Scalar Single-Precision Floating-Point Value To Unsigned Doubleword Integer
Data$ "VCVTTPD2QQ";	Convert With Truncation Packed Double-Precision Floating-Point Values To Packed Quadword Integers
Data$ "VCVTTPD2UDQ";	Convert With Truncation Packed Double-Precision Floating-Point Values To Packed Unsigned Doubleword Integers
Data$ "VCVTTPD2UQQ";	Convert With Truncation Packed Double-Precision Floating-Point Values To Packed Unsigned Quadword Integers
Data$ "VCVTTPS2QQ";	Convert With Truncation Packed Single Precision Floating-Point Values To Packed Singed Quadword Integer Values
Data$ "VCVTTPS2UDQ";	Convert With Truncation Packed Single-Precision Floating-Point Values To Packed Unsigned Doubleword Integer Values
Data$ "VCVTTPS2UQQ";	Convert With Truncation Packed Single Precision Floating-Point Values To Packed Unsigned Quadword Integer Values
Data$ "VCVTTSD2USI";	Convert With Truncation Scalar Double-Precision Floating-Point Value To Unsigned Integer
Data$ "VCVTTSS2USI";	Convert With Truncation Scalar Single-Precision Floating-Point Value To Unsigned Integer
Data$ "VCVTUDQ2PD";	Convert Packed Unsigned Doubleword Integers To Packed Double-Precision Floating-Point Values
Data$ "VCVTUDQ2PS";	Convert Packed Unsigned Doubleword Integers To Packed Single-Precision Floating-Point Values
Data$ "VCVTUQQ2PD";	Convert Packed Unsigned Quadword Integers To Packed Double-Precision Floating-Point Values
Data$ "VCVTUQQ2PS";	Convert Packed Unsigned Quadword Integers To Packed Single-Precision Floating-Point Values
Data$ "VCVTUSI2SD";	Convert Unsigned Integer To Scalar Double-Precision Floating-Point Value
Data$ "VCVTUSI2SS";	Convert Unsigned Integer To Scalar Single-Precision Floating-Point Value
Data$ "VDBPSADBW";	Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes
Data$ "VERR";	Verify a Segment For Reading Or Writing
Data$ "VERW";	Verify a Segment For Reading Or Writing
Data$ "VEXPANDPD";	Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory
Data$ "VEXPANDPS";	Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory
Data$ "VEXTRACTF128";	Extra ct Packed Floating-Point Values
Data$ "VEXTRACTF32x4";	Extra ct Packed Floating-Point Values
Data$ "VEXTRACTF32x8";	Extra ct Packed Floating-Point Values
Data$ "VEXTRACTF64x2";	Extra ct Packed Floating-Point Values
Data$ "VEXTRACTF64x4";	Extra ct Packed Floating-Point Values
Data$ "VEXTRACTI128";	Extract packed Integer Values
Data$ "VEXTRACTI32x4";	Extract packed Integer Values
Data$ "VEXTRACTI32x8";	Extract packed Integer Values
Data$ "VEXTRACTI64x2";	Extract packed Integer Values
Data$ "VEXTRACTI64x4";	Extract packed Integer Values
Data$ "VFIXUPIMMPD";	Fix Up Special Packed Float64 Values
Data$ "VFIXUPIMMPS";	Fix Up Special Packed Float32 Values
Data$ "VFIXUPIMMSD";	Fix Up Special Scalar Float64 Value
Data$ "VFIXUPIMMSS";	Fix Up Special Scalar Float32 Value
Data$ "VFMADD132PD";	Fused Multiply-Add of Packed Double- Precision Floating-Point Values
Data$ "VFMADD132PS";	Fused Multiply-Add of Packed Single- Precision Floating-Point Values
Data$ "VFMADD132SD";	Fused Multiply-Add of Scalar Double- Precision Floating-Point Values
Data$ "VFMADD132SS";	Fused Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFMADD213PD";	Fused Multiply-Add of Packed Double- Precision Floating-Point Values
Data$ "VFMADD213PS";	Fused Multiply-Add of Packed Single- Precision Floating-Point Values
Data$ "VFMADD213SD";	Fused Multiply-Add of Scalar Double- Precision Floating-Point Values
Data$ "VFMADD213SS";	Fused Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFMADD231PD";	Fused Multiply-Add of Packed Double- Precision Floating-Point Values
Data$ "VFMADD231PS";	Fused Multiply-Add of Packed Single- Precision Floating-Point Values
Data$ "VFMADD231SD";	Fused Multiply-Add of Scalar Double- Precision Floating-Point Values
Data$ "VFMADD231SS";	Fused Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFMADDSUB132PD";	Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFMADDSUB132PS";	Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFMADDSUB213PD";	Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFMADDSUB213PS";	Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFMADDSUB231PD";	Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFMADDSUB231PS";	Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFMSUB132PD";	Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values
Data$ "VFMSUB132PS";	Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values
Data$ "VFMSUB132SD";	Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values
Data$ "VFMSUB132SS";	Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values
Data$ "VFMSUB213PD";	Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values
Data$ "VFMSUB213PS";	Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values
Data$ "VFMSUB213SD";	Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values
Data$ "VFMSUB213SS";	Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values
Data$ "VFMSUB231PD";	Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values
Data$ "VFMSUB231PS";	Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values
Data$ "VFMSUB231SD";	Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values
Data$ "VFMSUB231SS";	Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values
Data$ "VFMSUBADD132PD";	Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values
Data$ "VFMSUBADD132PS";	Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values
Data$ "VFMSUBADD213PD";	Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values
Data$ "VFMSUBADD213PS";	Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values
Data$ "VFMSUBADD231PD";	Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values
Data$ "VFMSUBADD231PS";	Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values
Data$ "VFNMADD132PD";	Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
Data$ "VFNMADD132PS";	Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
Data$ "VFNMADD132SD";	Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
Data$ "VFNMADD132SS";	Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFNMADD213PD";	Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
Data$ "VFNMADD213PS";	Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
Data$ "VFNMADD213SD";	Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
Data$ "VFNMADD213SS";	Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFNMADD231PD";	Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
Data$ "VFNMADD231PS";	Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
Data$ "VFNMADD231SD";	Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
Data$ "VFNMADD231SS";	Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
Data$ "VFNMSUB132PD";	Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFNMSUB132PS";	Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFNMSUB132SD";	Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values
Data$ "VFNMSUB132SS";	Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values
Data$ "VFNMSUB213PD";	Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFNMSUB213PS";	Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFNMSUB213SD";	Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values
Data$ "VFNMSUB213SS";	Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values
Data$ "VFNMSUB231PD";	Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values
Data$ "VFNMSUB231PS";	Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values
Data$ "VFNMSUB231SD";	Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values
Data$ "VFNMSUB231SS";	Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values
Data$ "VFPCLASSPD";	Tests Types Of a Packed Float64 Values
Data$ "VFPCLASSPS";	Tests Types Of a Packed Float32 Values
Data$ "VFPCLASSSD";	Tests Types Of a Scalar Float64 Values
Data$ "VFPCLASSSS";	Tests Types Of a Scalar Float32 Values
Data$ "VGATHERDPD";	Gather Packed DP FP Values Using Signed Dword/Qword Indices
Data$ "VGATHERDPS";	Gather Packed SP FP values Using Signed Dword/Qword Indices
Data$ "VGATHERDPS"; (1)	Gather Packed Single, Packed Double With Signed Dword
Data$ "VGATHERQPD";	Gather Packed DP FP Values Using Signed Dword/Qword Indices
Data$ "VGATHERQPD"; (1)	Gather Packed Single, Packed Double With Signed Qword Indices
Data$ "VGATHERQPS";	Gather Packed SP FP values Using Signed Dword/Qword Indices
Data$ "VGATHERQPS"; (1)	Gather Packed Single, Packed Double With Signed Qword Indices
Data$ "VGETEXPPD";	Convert Exponents of Packed DP FP Values To DP FP Values
Data$ "VGETEXPPS";	Convert Exponents of Packed SP FP Values To SP FP Values
Data$ "VGETEXPSD";	Convert Exponents of Scalar DP FP Values To DP FP Value
Data$ "VGETEXPSS";	Convert Exponents of Scalar SP FP Values To SP FP Value
Data$ "VGETMANTPD";	Extract Float64 Vector of Normalized Mantissas from Float64 Vector
Data$ "VGETMANTPS";	Extract Float32 Vector of Normalized Mantissas from Float32 Vector
Data$ "VGETMANTSD";	Extract Float64 of Normalized Mantissas from Float64 Scalar
Data$ "VGETMANTSS";	Extract Float32 Vector of Normalized Mantissa from Float32 Vector
Data$ "VINSERTF128";	Insert Packed Floating-Point Values
Data$ "VINSERTF32x4";	Insert Packed Floating-Point Values
Data$ "VINSERTF32x8";	Insert Packed Floating-Point Values
Data$ "VINSERTF64x2";	Insert Packed Floating-Point Values
Data$ "VINSERTF64x4";	Insert Packed Floating-Point Values
Data$ "VINSERTI128";	Insert Packed Integer Values
Data$ "VINSERTI32x4";	Insert Packed Integer Values
Data$ "VINSERTI32x8";	Insert Packed Integer Values
Data$ "VINSERTI64x2";	Insert Packed Integer Values
Data$ "VINSERTI64x4";	Insert Packed Integer Values
Data$ "VMASKMOV";	Conditional SIMD Packed Loads And Stores
Data$ "VMOVDQA32";	Move Aligned Packed Integer Values
Data$ "VMOVDQA64";	Move Aligned Packed Integer Values
Data$ "VMOVDQU16";	Move Unaligned Packed Integer Values
Data$ "VMOVDQU32";	Move Unaligned Packed Integer Values
Data$ "VMOVDQU64";	Move Unaligned Packed Integer Values
Data$ "VMOVDQU8";	Move Unaligned Packed Integer Values
Data$ "VPBLENDD";	Blend Packed Dwords
Data$ "VPBLENDMB";	Blend Byte/Word Vectors Using an Opmask Control
Data$ "VPBLENDMD";	Blend Int32/Int64 Vectors Using an OpMask Control
Data$ "VPBLENDMQ";	Blend Int32/Int64 Vectors Using an OpMask Control
Data$ "VPBLENDMW";	Blend Byte/Word Vectors Using an Opmask Control
Data$ "VPBROADCAST";	Load Integer And Broadcast
Data$ "VPBROADCASTB";	Load With Broadcast Integer Data from General Purpose Register
Data$ "VPBROADCASTD";	Load With Broadcast Integer Data from General Purpose Register
Data$ "VPBROADCASTM";	Broadcast Mask To Vector Register
Data$ "VPBROADCASTQ";	Load With Broadcast Integer Data from General Purpose Register
Data$ "VPBROADCASTW";	Load With Broadcast Integer Data from General Purpose Register
Data$ "VPCMPB";	Compare Packed Byte Values Into Mask
Data$ "VPCMPD";	Compare Packed Integer Values into Mask
Data$ "VPCMPQ";	Compare Packed Integer Values into Mask
Data$ "VPCMPUB";	Compare Packed Byte Values Into Mask
Data$ "VPCMPUD";	Compare Packed Integer Values into Mask
Data$ "VPCMPUQ";	Compare Packed Integer Values into Mask
Data$ "VPCMPUW";	Compare Packed Word Values Into Mask
Data$ "VPCMPW";	Compare Packed Word Values Into Mask
Data$ "VPCOMPRESSD";	Store Sparse Packed Doubleword Integer Values into Dense Memory/Register
Data$ "VPCOMPRESSQ";	Store Sparse Packed Quadword Integer Values into Dense Memory/Register
Data$ "VPCONFLICTD";	Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register
Data$ "VPCONFLICTQ";	Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register
Data$ "VPERM2F128";	Permute Floating-Point Values
Data$ "VPERM2I128";	Permute Integer Values
Data$ "VPERMB";	Permute Packed Bytes Elements
Data$ "VPERMD";	Permute Packed Doublewords/Words Elements
Data$ "VPERMI2B";	Full Permute of Bytes from Two Tables Overwriting the Index
Data$ "VPERMI2D";	Full Permute From Two Tables Overwriting the Index
Data$ "VPERMI2PD";	Full Permute From Two Tables Overwriting the Index
Data$ "VPERMI2PS";	Full Permute From Two Tables Overwriting the Index
Data$ "VPERMI2Q";	Full Permute From Two Tables Overwriting the Index
Data$ "VPERMI2W";	Full Permute From Two Tables Overwriting the Index
Data$ "VPERMILPD";	Permute In-Lane of Pairs of Double-Precision Floating-Point Values
Data$ "VPERMILPS";	Permute In-Lane of Quadruples of Single-Precision Floating-Point Values
Data$ "VPERMPD";	Permute Double-Precision Floating-Point Elements
Data$ "VPERMPS";	Permute Single-Precision Floating-Point Elements
Data$ "VPERMQ";	Qwords Element Permutation
Data$ "VPERMT2B";	Full Permute of Bytes from Two Tables Overwriting a Table
Data$ "VPERMT2D";	Full Permute from Two Tables Overwriting one Table
Data$ "VPERMT2PD";	Full Permute from Two Tables Overwriting one Table
Data$ "VPERMT2PS";	Full Permute from Two Tables Overwriting one Table
Data$ "VPERMT2Q";	Full Permute from Two Tables Overwriting one Table
Data$ "VPERMT2W";	Full Permute from Two Tables Overwriting one Table
Data$ "VPERMW";	Permute Packed Doublewords/Words Elements
Data$ "VPEXPANDD";	Load Sparse Packed Doubleword Integer Values from Dense Memory / Register
Data$ "VPEXPANDQ";	Load Sparse Packed Quadword Integer Values from Dense Memory / Register
Data$ "VPGATHERDD";	Gather Packed Dword Values Using Signed Dword/Qword Indices
Data$ "VPGATHERDQ";	Gather Packed Dword, Packed Qword With Signed Dword Indices
Data$ "VPGATHERQD";	Gather Packed Dword Values Using Signed Dword/Qword Indices
Data$ "VPGATHERQQ";	Gather Packed Qword Values Using Signed Dword/Qword Indices
Data$ "VPLZCNTD";	Count the Number of Leading Zero Bits For Packed Dword, Packed Qword Values
Data$ "VPLZCNTQ";	Count the Number of Leading Zero Bits For Packed Dword, Packed Qword Values
Data$ "VPMADD52HUQ";	Packed Multiply of Unsigned 52-bit Unsigned Integers And Add High 52-bit Products To 64-bit Accumulators
Data$ "VPMADD52LUQ";	Packed Multiply of Unsigned 52-bit Integers And Add the Low 52-bit Products To Qword Accumulators
Data$ "VPMASKMOV";	Conditional SIMD Integer Packed Loads And Stores
Data$ "VPMOVB2M";	Convert a Vector Register To a Mask
Data$ "VPMOVD2M";	Convert a Vector Register To a Mask
Data$ "VPMOVDB";	Down Convert DWord To Byte
Data$ "VPMOVDW";	Down Convert DWord To Word
Data$ "VPMOVM2B";	Convert a Mask Register To a Vector Register
Data$ "VPMOVM2D";	Convert a Mask Register To a Vector Register
Data$ "VPMOVM2Q";	Convert a Mask Register To a Vector Register
Data$ "VPMOVM2W";	Convert a Mask Register To a Vector Register
Data$ "VPMOVQ2M";	Convert a Vector Register To a Mask
Data$ "VPMOVQB";	Down Convert QWord To Byte
Data$ "VPMOVQD";	Down Convert QWord To DWord
Data$ "VPMOVQW";	Down Convert QWord To Word
Data$ "VPMOVSDB";	Down Convert DWord To Byte
Data$ "VPMOVSDW";	Down Convert DWord To Word
Data$ "VPMOVSQB";	Down Convert QWord To Byte
Data$ "VPMOVSQD";	Down Convert QWord To DWord
Data$ "VPMOVSQW";	Down Convert QWord To Word
Data$ "VPMOVSWB";	Down Convert Word To Byte
Data$ "VPMOVUSDB";	Down Convert DWord To Byte
Data$ "VPMOVUSDW";	Down Convert DWord To Word
Data$ "VPMOVUSQB";	Down Convert QWord To Byte
Data$ "VPMOVUSQD";	Down Convert QWord To DWord
Data$ "VPMOVUSQW";	Down Convert QWord To Word
Data$ "VPMOVUSWB";	Down Convert Word To Byte
Data$ "VPMOVW2M";	Convert a Vector Register To a Mask
Data$ "VPMOVWB";	Down Convert Word To Byte
Data$ "VPMULTISHIFTQB";	Select Packed Unaligned Bytes from Quadword Sources
Data$ "VPROLD";	Bit Rotate Left
Data$ "VPROLQ";	Bit Rotate Left
Data$ "VPROLVD";	Bit Rotate Left
Data$ "VPROLVQ";	Bit Rotate Left
Data$ "VPRORD";	Bit Rotate Right
Data$ "VPRORQ";	Bit Rotate Right
Data$ "VPRORVD";	Bit Rotate Right
Data$ "VPRORVQ";	Bit Rotate Right
Data$ "VPSCATTERDD";	Scatter Packed Dword, Packed Qword With Signed Dword, Signed Qword Indices
Data$ "VPSCATTERDQ";	Scatter Packed Dword, Packed Qword With Signed Dword, Signed Qword Indices
Data$ "VPSCATTERQD";	Scatter Packed Dword, Packed Qword With Signed Dword, Signed Qword Indices
Data$ "VPSCATTERQQ";	Scatter Packed Dword, Packed Qword With Signed Dword, Signed Qword Indices
Data$ "VPSLLVD";	Variable Bit Shift Left Logical
Data$ "VPSLLVQ";	Variable Bit Shift Left Logical
Data$ "VPSLLVW";	Variable Bit Shift Left Logical
Data$ "VPSRAVD";	Variable Bit Shift Right Arithmetic
Data$ "VPSRAVQ";	Variable Bit Shift Right Arithmetic
Data$ "VPSRAVW";	Variable Bit Shift Right Arithmetic
Data$ "VPSRLVD";	Variable Bit Shift Right Logical
Data$ "VPSRLVQ";	Variable Bit Shift Right Logical
Data$ "VPSRLVW";	Variable Bit Shift Right Logical
Data$ "VPTERNLOGD";	Bitwise Ternary Logic
Data$ "VPTERNLOGQ";	Bitwise Ternary Logic
Data$ "VPTESTMB";	Logical And And Set Mask
Data$ "VPTESTMD";	Logical And And Set Mask
Data$ "VPTESTMQ";	Logical And And Set Mask
Data$ "VPTESTMW";	Logical And And Set Mask
Data$ "VPTESTNMB";	Logical NAND And Set
Data$ "VPTESTNMD";	Logical NAND And Set
Data$ "VPTESTNMQ";	Logical NAND And Set
Data$ "VPTESTNMW";	Logical NAND And Set
Data$ "VRANGEPD";	Range Restriction Calculation For Packed Pairs of Float64 Values
Data$ "VRANGEPS";	Range Restriction Calculation For Packed Pairs of Float32 Values
Data$ "VRANGESD";	Range Restriction Calculation From a pair of Scalar Float64 Values
Data$ "VRANGESS";	Range Restriction Calculation From a Pair of Scalar Float32 Values
Data$ "VRCP14PD";	Compute Approximate Reciprocals of Packed Float64 Values
Data$ "VRCP14PS";	Compute Approximate Reciprocals of Packed Float32 Values
Data$ "VRCP14SD";	Compute Approximate Reciprocal of Scalar Float64 Value
Data$ "VRCP14SS";	Compute Approximate Reciprocal of Scalar Float32 Value
Data$ "VREDUCEPD";	Perform Reduction Transformation on Packed Float64 Values
Data$ "VREDUCEPS";	Perform Reduction Transformation on Packed Float32 Values
Data$ "VREDUCESD";	Perform a Reduction Transformation on a Scalar Float64 Value
Data$ "VREDUCESS";	Perform a Reduction Transformation on a Scalar Float32 Value
Data$ "VRNDSCALEPD";	Round Packed Float64 Values To Include A Given Number Of Fraction Bits
Data$ "VRNDSCALEPS";	Round Packed Float32 Values To Include A Given Number Of Fraction Bits
Data$ "VRNDSCALESD";	Round Scalar Float64 Value To Include A Given Number Of Fraction Bits
Data$ "VRNDSCALESS";	Round Scalar Float32 Value To Include A Given Number Of Fraction Bits
Data$ "VRSQRT14PD";	Compute Approximate Reciprocals of Square Roots of Packed Float64 Values
Data$ "VRSQRT14PS";	Compute Approximate Reciprocals of Square Roots of Packed Float32 Values
Data$ "VRSQRT14SD";	Compute Approximate Reciprocal of Square Root of Scalar Float64 Value
Data$ "VRSQRT14SS";	Compute Approximate Reciprocal of Square Root of Scalar Float32 Value
Data$ "VSCALEFPD";	Scale Packed Float64 Values With Float64 Values
Data$ "VSCALEFPS";	Scale Packed Float32 Values With Float32 Values
Data$ "VSCALEFSD";	Scale Scalar Float64 Values With Float64 Values
Data$ "VSCALEFSS";	Scale Scalar Float32 Value With Float32 Value
Data$ "VSCATTERDPD";	Scatter Packed Single, Packed Double With Signed Dword And Qword Indices
Data$ "VSCATTERDPS";	Scatter Packed Single, Packed Double With Signed Dword And Qword Indices
Data$ "VSCATTERQPD";	Scatter Packed Single, Packed Double With Signed Dword And Qword Indices
Data$ "VSCATTERQPS";	Scatter Packed Single, Packed Double With Signed Dword And Qword Indices
Data$ "VSHUFF32x4";	Shuffle Packed Values at 128-bit Granularity
Data$ "VSHUFF64x2";	Shuffle Packed Values at 128-bit Granularity
Data$ "VSHUFI32x4";	Shuffle Packed Values at 128-bit Granularity
Data$ "VSHUFI64x2";	Shuffle Packed Values at 128-bit Granularity
Data$ "VTESTPD";	Packed Bit Test
Data$ "VTESTPS";	Packed Bit Test
Data$ "VZEROALL";	Zero All YMM Registers
Data$ "VZEROUPPER";	Zero Upper Bits of YMM Registers
Data$ "WAIT";	Wait
Data$ "WBINVD";	Write Back And Invalidate Cache
Data$ "WRFSBASE";	Write FS/GS Segment Base
Data$ "WRGSBASE";	Write FS/GS Segment Base
Data$ "WRMSR";	Write To Model Specific Register
Data$ "WRPKRU";	Write Data To User Page Key Register
Data$ "XABORT";	Transactional Abort
Data$ "XACQUIRE";	Hardware Lock Elision Prefix Hints
Data$ "XADD";	Exchange And Add
Data$ "XBEGIN";	Transactional Begin
Data$ "XCHG";	Exchange Register/Memory With Register
Data$ "XEND";	Transactional End
Data$ "XGETBV";	Get Value of Extended Control Register
Data$ "XLAT";	Table Look-up Translation
Data$ "XLATB";	Table Look-up Translation
Data$ "XOR";	Logical Exclusive Or
Data$ "XORPD";	Bitwise Logical XOr of Packed Double Precision Floating-Point Values
Data$ "XORPS";	Bitwise Logical XOr of Packed Single Precision Floating-Point Values
Data$ "XRELEASE";	Hardware Lock Elision Prefix Hints
Data$ "XRSTOR";	Restore Processor Extended States
Data$ "XRSTORS";	Restore Processor Extended States Supervisor
Data$ "XSAVE";	Save Processor Extended States
Data$ "XSAVEC";	Save Processor Extended States With Compaction
Data$ "XSAVEOPT";	Save Processor Extended States Optimized
Data$ "XSAVES";	Save Processor Extended States Supervisor
Data$ "XSETBV";	Set Extended Control Register
Data$ "XTEST";	Test If In Transactional Execution
