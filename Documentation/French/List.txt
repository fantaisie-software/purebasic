;
; List library documentation
;
; (c) Fantaisie Software
;

@Library List

@Overview

  Les listes (aussi appelée listes chaînées) 
  regroupent des objets qui sont alloués 
  dynamiquement en fonction de vos besoins. 
  Elles se présentent sous la forme de listes 
  d'éléments totalement indépendants les uns 
  des autres. Vous pouvez y ajouter un nombre 
  infini d'éléments, insérer des éléments à 
  une position choisie, en effacer, etc... 
  Cette méthode de stockage d'informations 
  est très pratique et très souple. C'est la 
  meilleure solution pour gérer des données 
  dont vous ne connaissez pas le nombre à 
  l'avance.
@LineBreak
@LineBreak
  Avant de travailler avec les listes, vous 
  devez les déclarer. Cela se fait avec le 
  mot-clef @ReferenceLink "newlist" "NewList".
  Les @ReferenceLink "structures" "structures" 
  sont également fréquemment utilisées dans 
  les listes.
@LineBreak
@LineBreak
  Les listes peuvent être triées à l'aide des 
  fonctions @@SortList ou @@SortStructuredList 
  de la bibliothèque @LibraryLink "sort" "Sort" 
  et peuvent être aussi mélangées de façon 
  aléatoire en utilisant @@RandomizeList.
@LineBreak
@LineBreak
  Pour analyser le contenu  d'une liste, il 
  est possible d'utiliser les boucles 
  suivantes: 
  @ReferenceLink "for_next" "For : Next", 
  @ReferenceLink "foreach_next" "ForEach : Next", 
  @ReferenceLink "repeat_until" "Repeat : Until" 
  ou @ReferenceLink "while_wend" "While : Wend".
@LineBreak
@LineBreak
  Le premier élément a la position 0, le deuxième la position 1, etc.. 
@LineBreak
@LineBreak
  Les autres possibilités pour stocker des 
  données multiples sont les 
  @LibraryLink "array" "Tableaux" et
  les @LibraryLink "map" "Maps".
@LineBreak
@LineBreak
  Lors de l'utilisation de @LibraryLink "thread" "threads", une liste donnée ne peut pas être consultée et modifiée en même temps 
  dans différents threads. Les mutexes peuvent être utilisés pour garantir que la liste ne soit utilisée que par un seul thread.

@CommandList

@Section &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tri & divers
  @@SortList @LineBreak
  @@SortStructuredList @LineBreak
  @@RandomizeList @LineBreak

  
@ExampleFile All List.pb

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = AddElement(Liste())

@Description
  Ajoute un nouvel élément après l'élément 
  courant.

@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie une valeur non nulle qui est l'adresse du nouvel élément si le nouvel 
  élément a été ajouté, zéro sinon. 
@linebreak
@linebreak
  La valeur renvoyée est un 
  @ReferenceLink "memory" "pointeur" sur le nouvel élément.

@Remarks
  Devient le premier élément si la liste 
  était vide et il devient l'élément courant 
  de la liste. 
  
@Example
@Code
  ; La manière la plus simple d'utiliser AddElement
  NewList simple.w()
  AddElement(simple())    ; Crée le premier nouvel élément de la liste
  simple() = 23

  AddElement(simple())    ; La position courante est le premier élément, alors nous en ajoutons un à la deuxième position
  simple() = 45


  ; Ceci montre comment utiliser la valeur de retour de la fonction AddElement
  NewList experimentes.l()
  If AddElement(experimentes()) <> 0
    experimentes() = 12345
  Else
    MessageRequester("Erreur !", "Impossible d'allouer de la mémoire pour le nouvel élément", #PB_MessageRequester_OK)
  EndIf


  ; Une petite structure pour montrer l'utilisation du pointeur.
  Structure Programmeur
    Nom.s
    Talent.b
  EndStructure

  NewList LesProgrammeurs.Programmeur()  ; La liste qui stocke les éléments

  *Element.Programmeur = AddElement(LesProgrammeurs())
  If *Element<>0
    *Element\Nom = "David"
    *Element\Talent = 3   ; Celui-là, c'est un féru de PureBasic ! ;)
  Else
    MessageRequester("Erreur !", "Impossible d'allouer de la mémoire pour le nouvel élément", #PB_MessageRequester_OK)
  EndIf
@EndCode

@SeeAlso
  @@InsertElement, @@DeleteElement, 
  @@ClearList
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function ChangeCurrentElement(Liste(), *NouvelElement)

@Description
  Change l'élément courant de la liste. 

@Parameter "Liste()" 
  La liste à utiliser.

@Parameter "*NouvelElement" 
  Le nouvel élément à placer à la position 
  courante de la liste.
@linebreak
@linebreak
  C'est un 
  @ReferenceLink "memory" "pointeur" vers 
  un autre élément qui existe déjà dans la 
  liste.
@linebreak
@linebreak
  Cette adresse doit être récupérée avec 
  l'opérateur @ et le nom de la liste et 
  pas autrement.
  
@NoReturnValue

@Remarks
  Cette fonction est très utile pour 
  mémoriser un élément et le réutiliser 
  après avoir exécuté d'autres traitements

@Example Simple
@Code
  *Ancien_Element = @MaListe()   ; On mémorise l'adresse de l'élément courant 
  
  ResetList(MaListe())           ; Effectue une recherche de tous les éléments nommés
  While NextElement(MaListe())   ; "Jean" et les change en "J" 
    If MaListe()\nom = "Jean"
      MaListe()\nom = "J"     
    EndIf 
  Wend     
  
  ChangeCurrentElement(MaListe(), *Ancien_Element) ; Restitue l'ancien élément courant (mémorisé avant la recherche)
@EndCode

@Example Complet
@Code
  NewList maList()
  
  AddElement(maList())
  maList() = 100
  
  AddElement(maList())
  maList() = 200
  *element = @maList()
  
  AddElement(maList())
  maList() = 300
  
  Debug maList()                             ; Affiche 300 (dernier élément)
  ChangeCurrentElement(maList(), *element)   ; Restaure la position de la liste
  Debug maList()                             ; Affiche 200
  
  ForEach maList()
    If @maList() = *element
      Debug "élément: " + maList()           ; Affiche "élément: 200"
    EndIf
  Next
@EndCode
  
@SeeAlso
  @@SelectElement, @@PushListPosition, @@PopListPosition

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function ClearList(Liste()) 

@Description
  Efface tous les éléments d'une liste et 
  libère la mémoire utilisée. 

@Parameter "Liste()"
  La liste à utiliser.

@NoReturnValue

@Remarks
  Après l'appel à cette fonction, la liste 
  reste utilisable, mais elle ne contient 
  plus d'éléments. PureBasic libèrera 
  seulement la mémoire occupée par les 
  éléments.
@linebreak 
  Si la liste a été utilisée pour stocker 
  des objets dynamiques, il n'est pas 
  possible de le détecter (en PureBasic 
  ou dans un autre langage). Dans ce cas, 
  il convient de libérer tous ces objets 
  avant la  destruction de la liste.
  
@Example
@Code
  NewList nombres.w()

  ; Une petite boucle pour ajouter plusieurs éléments à la liste
  For i=1 To 100
    AddElement(nombres())
    nombres() = i
  Next

  ; Preuve que les éléments ont été ajoutés à la liste
  MessageRequester("Information", "Il y a "+Str(ListSize(nombres()))+" éléments dans la liste", #PB_MessageRequester_OK)
 
  ; Effacer la liste et montrer que la liste est vraiment vide
  ClearList(nombres())
  MessageRequester("Information", "Il y a "+Str(ListSize(nombres()))+" élements dans la liste", #PB_MessageRequester_OK)
@EndCode

@SeeAlso
  @@DeleteElement, @@FreeList
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CompareList(Liste1(), Liste2() [, Options])

@Description
  Compare chaque élément des deux listes pour vérifier leur égalité. 

@parameter "Liste1(), Liste2()"
  Les listes à comparer.
  
@OptionalParameter "Options"
   Peut être une combinaison des valeurs suivantes :
@FixedFont
   @#PB_String_CaseSensitive  : La comparaison des chaînes est sensible à la casse (a=a). (par défaut)
   @#PB_String_NoCase         : La comparaison des chaînes n'est pas sensible à la casse (A=a).
   @#PB_Memory_FollowPointers : Si un élément de structure est un pointeur qui n'est pas 0, compare récursivement la cible du pointeur.
                               La valeur par défaut consiste à comparer uniquement la valeur (existante) du pointeur elle-même.
@EndFixedFont

@ReturnValue
  Renvoie une valeur non nulle si les deux listes sont identiques, zéro sinon.

@Remarks
  Compare de manière récursive également le contenu de listes structurées avec des éléments 
  dynamiques (tels que des tableaux intégrés, des listes ou des maps).@linebreak
  Les deux listes sont considérées comme égales si elles ont le même type et la même taille 
  et si chaque paire d’éléments est identique.
@LineBreak
@LineBreak
   L'option @#PB_Memory_FollowPointers est destinée aux utilisateurs avancés et nécessite une attention 
   particulière pour éviter les plantages. Si cette option est utilisée, alors toutes les valeurs de 
   pointeur doivent pointer vers une mémoire valide et initialisée ou avoir la valeur 0. Il n'est 
   pas non plus autorisé d'avoir des boucles dans les éléments pointés (une chaîne de pointeurs qui 
   se renvoie à elle-même).
   
@Example
@Code
  NewList A$()
  AddElement(A$()) : A$() = "Jean"
  AddElement(A$()) : A$() = "Charles"
  AddElement(A$()) : A$() = "Didier"
  
  NewList B$()
  AddElement(B$()) : B$() = "JEAN"  ; Casse différente
  AddElement(B$()) : B$() = "Charles"
  AddElement(B$()) : B$() = "Didier"
  
  Debug CompareList(A$(), B$())                     ; Pas égal
  Debug CompareList(A$(), B$(), #PB_String_NoCase)  ; Égal
@EndCode

@SeeAlso
  @@CompareArray, @@CompareMap

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CopyList(ListeSource(), ListeDestination())

@Description
  Copie tous les éléments d'une liste 
  dans une autre.

@Parameter "ListeSource()"
  La liste à copier.

@Parameter "ListeDestination()"
  La copie de la liste. 
@linebreak
@linebreak
  Tous les éléments présents avant la copie 
  seront effacés.
  @linebreak
  Si les deux listes ne sont pas du même 
  type (natif ou structuré) la copie ne
  se fera pas.

@ReturnValue
  Renvoie une valeur non nulle si la copie 
  a réussi, zéro sinon.

@Example
@Code
  NewList Amis$()
  NewList AmisCopie$()
  
  AddElement(Amis$())
  Amis$() = "Jean"
  
  AddElement(Amis$())
  Amis$() = "Elise"

  CopyList(Amis$(), AmisCopie$())
  
  ForEach AmisCopie$()
    Debug AmisCopie$()
  Next
@EndCode

@SeeAlso
  @@CopyArray, @@CopyMap

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function FreeList(Liste())

@Description
  Détruit la liste et libère toutes les 
  ressources associées. 

@Parameter "Liste()"
  La liste à détruire et ne peut être 
  réutilisée, contrairement à @@ClearList. 

@NoReturnValue

@Remarks
  Pour accéder à cette liste à nouveau, 
  il faut la recréer avec 
  @ReferenceLink "newlist" "NewList".

@SeeAlso
  @@ClearList

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = ListSize(Liste()) 

@Description
  Renvoie le nombre d'éléments contenus dans la liste. 

@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Le nombre total d'éléments dans la liste.@linebreak
  Si la liste n'est pas initialisée, renvoie -1 (par exemple après @@FreeList).

@Remarks
  Cette fonction ne modifie pas l'élément courant. @LineBreak
  Elle est très rapide (pas d'itération) et peut être utilisée sereinement pour savoir 
  si une liste est vide ou non.
  
@Example
@Code
  NewList Compter.w()

  ; Petite boucle pour ajouter quelques éléments à la liste.
  For i=0 To 10
    AddElement(Compter())
    Compter() = i * 23
  Next

  ; Affiche le nombre d'éléments qu'il y a dans la liste. J'espère que vous avez pensé
  ; à la même valeur que celle affichée par l'ordinateur ;)
  MessageRequester("Information", "Il y a "+Str(ListSize(Compter()))+" éléments dans la liste", #PB_MessageRequester_OK)
@EndCode

@SeeAlso
  @@ListIndex

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CountList(Liste())

@Description
@Deprecated
  
  Cette fonction a été remplacée par 
  @@ListSize. 

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = DeleteElement(Liste() [, Options])  

@Description
  Supprime l'élément courant de la liste. 

@Parameter "Liste()"
  La liste à utiliser.

@OptionalParameter "Options"
  Si ce paramètre est égal à 1 et que le premier élément est supprimé 
  alors le nouvel élément courant sera le second élément. 
  @LineBreak
  Cette option veille à ce qu'il y ait toujours un élément en cours de validité 
  après une suppression aussi longtemps qu'il y a encore des éléments de la liste.
  
@ReturnValue
  Renvoie une valeur non nulle qui est l'adresse du nouvel élément courant.
  @LineBreak
  Si la liste ne comporte aucun élément courant après la suppression, le résultat est 0.
@linebreak
@linebreak
  La valeur renvoyée est un 
  @ReferenceLink "memory" "pointeur" sur le nouvel élément.

@Remarks
  Fonctionnement: Après l'appel de cette fonction, le nouvel
  élément courant est celui qui précédait 
  l'élément supprimé. Si l'élément supprimé 
  était le premier, alors il n'y a plus 
  d'élément courant (la position dans la 
  liste est avant le premier élément, comme 
  après un @@ResetList) sauf si Option=1 car dans
  ce cas le nouvel élément serait celui qui était en seconde 
  position.

@Example
@Code
  NewList personnes.s()

  AddElement(personnes()) : personnes() = "Tom"
  AddElement(personnes()) : personnes() = "Dick"
  AddElement(personnes()) : personnes() = "Harry"
  AddElement(personnes()) : personnes() = "Bob"

  FirstElement(personnes())     ; se déplace sur "Tom"
  DeleteElement(personnes(),1)  ; et le supprime. L'élément courant devient (paramètre 1 utilisé) celui qui suivait
  MessageRequester("Information", "La première personne de la liste est "+personnes(), #PB_MessageRequester_OK)

  LastElement(personnes())      ; se déplace vers "Bob"
  PreviousElement(personnes())  ; se déplace vers "Harry"
  DeleteElement(personnes())    ; et le supprime.Il y a un élément avant Harry, alors il devient l'élément courant
  MessageRequester("Information", "La personne actuellement pointée dans la liste est "+personnes(), #PB_MessageRequester_OK)
@EndCode

@SeeAlso
  @@AddElement, @@InsertElement, 
  @@ClearList

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = FirstElement(Liste())

@Description
  Le premier élément de la liste devient 
  l'élément courant. 
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie une valeur non nulle qui est l'adresse du premierr élément, zéro si le premier élément n'existe pas. 
@linebreak
@linebreak
  La valeur renvoyée est un 
  @ReferenceLink "memory" "pointeur" sur le premier élément s'il existe.
  
@Example
@Code
  ; Un exemple d'utilisation simple
  NewList nombres.w()

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  FirstElement(nombres())
  MessageRequester("Information", "La valeur du premier élément est "+Str(nombres()), #PB_MessageRequester_OK)


  ; Un exemple qui utilise la valeur de retour
  NewList nombres.w()

  If FirstElement(nombres()) <> 0
    MessageRequester("Information", "La valeur du premier élément est "+Str(nombres()), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  If FirstElement(nombres()) <> 0
    MessageRequester("Information", "La valeur du premier élément est "+Str(nombres()), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf


  ; Un exemple réservé aux programmeurs expérimentés
  NewList nombres.w()

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  *Element.Word = FirstElement(nombres())
  If *Element
    MessageRequester("Information", "La valeur du premier élément est "+Str(*Element\w), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf
@EndCode

@SeeAlso
  @@LastElement, @@PreviousElement, 
  @@NextElement, @@SelectElement, 
  @@ListIndex
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = InsertElement(Liste()) 

@Description
 Insère un nouvel élément avant l'élément 
 courant, ou au début de la liste si la 
 liste est vide. Ce nouvel élément devient
 l'élément courant de la liste.
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie une valeur non nulle qui est l'adresse du nouvel élément si le nouvel 
  élément a été créé, zéro sinon.
  @linebreak
  La valeur renvoyée par cette commande est 
  un @ReferenceLink "memory" "pointeur" 
  vers les données du nouvel élément. 
 
@Example
@Code
  ; La manière la plus simple d'utiliser InsertElement
  NewList simple.w()
  InsertElement(simple())    ; Crée le premier élément de la liste
  simple() = 23

  InsertElement(simple())    ; La position courante est le premier élément, nous ajoutons cet élément au début de la liste
  simple() = 45              ; L'ancien premier élément est maintenant le second élément de la liste


  ; Ceci montre comment utiliser la valeur de retour de InsertElement
  NewList experimentes.l()
  If InsertElement(experimentes()) <> 0
    experimentes() = 12345
  Else
    MessageRequester("Erreur !", "Impossible d'allouer de la mémoire pour le nouvel élément", #PB_MessageRequester_OK)
  EndIf


  ; Une petite structure pour démontrer la description "programmeurs expérimentés" (ci-dessus)
  Structure Programmeur
    Nom.s
    Talent.b
  EndStructure

  NewList LesProgrammeurs.Programmeur()  ; La liste pour stocker les éléments

  *Element.Programmeur = InsertElement(LesProgrammeurs())
  If *Element<>0
    *Element\Nom = "Dave"
    *Element\Talent = 3   ; Celui-là, c'est un féru de PureBasic ! ;)
  Else
    MessageRequester("Erreur !", "Impossible d'allouer de la mémoire pour le nouvel élément", #PB_MessageRequester_OK)
  EndIf
@EndCode

@SeeAlso
  @@AddElement, @@DeleteElement, @@ClearList

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = LastElement(Liste())

@Description
  Le dernier élément de la liste devient 
  l'élément courant.
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie l'adresse du dernier élément de 
  la liste ou zéro s'il n'y a pas d'éléments.
@linebreak
  La valeur renvoyée par cette commande est 
  un @ReferenceLink "memory" "pointeur" 
  vers les données du dernier élément s'il existe.
  
@Example  
@Code
  ; Un exemple d'utilisation simple
  NewList nombres.w()

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  LastElement(nombres())
  MessageRequester("Information", "La valeur du dernier élément est "+Str(nombres()), #PB_MessageRequester_OK)


  ; Un exemple qui utilise la valeur de retour
  NewList nombres.w()

  If LastElement(nombres()) <> 0
    MessageRequester("Information", "La valeur du dernier élément est "+Str(nombres()), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  If LastElement(nombres()) <> 0
    MessageRequester("Information", "La valeur du dernier élément est "+Str(nombres()), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf


  ; Un exemple réservé aux programmeurs expérimentés
  NewList nombres.w()

  AddElement(nombres())
  nombres() = 5
  AddElement(nombres())
  nombres() = 8

  *Element.Word = LastElement(nombres())
  If *Element
    MessageRequester("Information", "La valeur du dernier élément est "+Str(*Element\w), #PB_MessageRequester_OK)
  Else
    MessageRequester("Information", "La liste est vide", #PB_MessageRequester_OK)
  EndIf
@EndCode

@SeeAlso
  @@FirstElement, @@PreviousElement, 
  @@NextElement, @@SelectElement, 
  @@ListIndex
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = ListIndex(Liste()) 

@Description
  Renvoie la position de l'élément courant 
  de la liste. 
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  La position de l'élément courant dans la 
  liste. 
@LineBreak
@LineBreak
  Le premier élément a la position 0, le 
  deuxième la position 1, etc.. 
@LineBreak
@LineBreak
  Une valeur de -1 indique qu'il n'y a pas 
  d'élément courant (soit la liste est vide, 
  soit @@ResetList a été utilisé).
  
@Remarks
  Cette commande est très rapide car elle 
  utilise une valeur précalculée.

@Example
@Code
  NewList fruit.s()

  AddElement(fruit()) : fruit() = "oranges"
  AddElement(fruit()) : fruit() = "bananes"
  AddElement(fruit()) : fruit() = "pommes"
  AddElement(fruit()) : fruit() = "poires"

  FirstElement(fruit())
  MessageRequester("Fruit : "+fruit(), "Maintenant à la position "+Str(ListIndex(fruit())),  #PB_MessageRequester_OK)

  NextElement(fruit())
  MessageRequester("Fruit : "+fruit(), "Maintenant à la position "+Str(ListIndex(fruit())),  #PB_MessageRequester_OK)

  NextElement(fruit())
  MessageRequester("Fruit : "+fruit(), "Maintenant à la position "+Str(ListIndex(fruit())),  #PB_MessageRequester_OK)

  NextElement(fruit())
  MessageRequester("Fruit : "+fruit(), "Maintenant à la position "+Str(ListIndex(fruit())),  #PB_MessageRequester_OK)
@EndCode

@SeeAlso
  @@SelectElement, @@ListSize

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = NextElement(Liste())  

@Description
  L'élément suivant devient l'élément 
  courant. 
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie l'adresse de l'élément suivant 
  en cas de succès ou zéro s'il n'y a pas 
  d'élément suivant.
 @linebreak
  La valeur renvoyée par cette commande est 
  un @ReferenceLink "memory" "pointeur" 
  vers les données de l'élément suivant s'il existe. 
  
@Remarks
  Passe au premier élément si @@ResetList a été utilisé.

@Example
@Code
  NewList scores.w()

  For i=1 To 10
    AddElement(scores())
    scores() = 100 - i
  Next

  ResetList(scores())
  While NextElement(scores())
    ; Ceci est correct car le premier appel à NextElement() va déplacer l'élément courant vers le premier élément de la liste
    MessageRequester("Score", Str(scores()), #PB_MessageRequester_OK)
  Wend
@EndCode

@SeeAlso
  @@ResetList, @@PreviousElement, 
  @@FirstElement, @@LastElement, 
  @@SelectElement, @@ListIndex

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = PreviousElement(Liste()) 

@Description
  L'élément précédent devient l'élément 
  courant. 
  
@Parameter "Liste()"
  La liste à utiliser.

@ReturnValue
  Renvoie l'adresse de l'élément précédent 
  en cas de succès ou zéro s'il n'y a pas 
  d'élément précédent.
  @linebreak
  La valeur renvoyée par cette commande est 
  un @ReferenceLink "memory" "pointeur" 
  vers les données de l'élément précédent s'il existe.

@Example
@Code
  NewList nombres.w()

  For i=1 To 10
    AddElement(nombres())
    nombres() = i
  Next

  Repeat
    MessageRequester("Nombre ", Str(nombres()), #PB_MessageRequester_OK)
  Until PreviousElement(nombres()) = 0
@EndCode

@SeeAlso
  @@NextElement,
  @@FirstElement, @@LastElement, 
  @@SelectElement, @@ListIndex

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function ResetList(Liste()) 

@Description
  Change l'index de l'élément courant et le 
  place avant le premier élément de la liste.
  Donc il n'y a plus d'éléments valides. 
 
@Parameter "Liste()"
  La liste à utiliser.

@NoReturnValue
  
@Remarks
  C'est particulièrement utile pour parcourir 
  tous les éléments avec @@NextElement.

@Example
@Code
  NewList Amis.s()
  
  AddElement(Amis())
  Amis() = "Arnaud"
  
  AddElement(Amis())
  Amis() = "Seb"
  
  ResetList(Amis())
  While NextElement(Amis())
    Debug Amis() ; Affiche tous les éléments de la liste
  Wend
@EndCode

@SeeAlso
  @@NextElement, @@ListIndex

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = SelectElement(Liste(), Position)
  
@Description
  Change l'élément courant par celui trouvé à 
  la position spécifiée.
  
@Parameter "Liste()"
  La liste à utiliser.

@Parameter "Position"
  La position du nouvel élément courant.
@linebreak
@linebreak
  Le premier élément de la liste
  est à la position 0, le suivant à la 
  position 1 et ainsi de suite.
  Assurez-vous de ne pas spécifier une 
  position située en dehors de la liste 
  (valeur négative ou supérieure à 
  @@ListSize -1) !

@ReturnValue
  Renvoie un 
  @ReferenceLink "memory" "pointeur" vers 
  les données de l'élément sélectionné
  ou zéro si la position est hors limite.

@Remarks
  Ceci est très utile si vous souhaitez 
  sauter à une position précise de la liste.
  Comme les listes n'utilisent pas d'index, 
  un saut d'élément en élément est effectué 
  jusqu'à la position cible recherchée. Si 
  une commande plus rapide est nécessaire, 
  utilisez la commande @@ChangeCurrentElement.

@Example
@Code
  NewList MaListe.l()

  AddElement(MaListe()) : MaListe() = 23
  AddElement(MaListe()) : MaListe() = 56
  AddElement(MaListe()) : MaListe() = 12
  AddElement(MaListe()) : MaListe() = 73

  SelectElement(MaListe(), 0)
  MessageRequester("Position", "A la position 0, la valeur est "+Str(MaListe()),0)

  SelectElement(MaListe(), 2)
  MessageRequester("Position", "A la position 2, la valeur est "+Str(MaListe()),0)

  SelectElement(MaListe(), 1)
  MessageRequester("Position", "A la position 1, la valeur est "+Str(MaListe()),0)

  SelectElement(MaListe(), 3)
  MessageRequester("Position", "A la position 3, la valeur est "+Str(MaListe()),0)
@EndCode

@SeeAlso 
  @@ChangeCurrentElement
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function SwapElements(Liste(), *PremierElement, *DeuxiemeElement)

@Description
  Permute la place de 2 éléments de la liste.
    
@Parameter "Liste()"
  La liste à utiliser.

@Parameter "*PremierElement"
  @ReferenceLink "memory" "Adresse" du 
  premier élément à échanger. 
@linebreak
@linebreak
  Vous pouvez récupérer cette adresse en 
  utilisant l'opérateur @ sur le nom de la 
  liste.

@Parameter "*DeuxiemeElement"
  @ReferenceLink "memory" "Adresse" du 
  second élément à échanger. 
@linebreak
@linebreak
  Vous pouvez récupérer cette adresse en 
  utilisant l'opérateur @ sur le nom de la 
  liste.

@NoReturnValue

@Remarks
  Cette fonction procure une façon rapide 
  pour réorganiser ou trier une liste 
  car les éléments ne sont pas déplacés. 

@Example
@Code
  NewList Nombres()
  
  For k=0 To 10
    AddElement(Nombres())
    Nombres() = k
  Next
    
  SelectElement(Nombres(), 3) ; Sélectionne le 4ème élément
  *PremierElement = @Nombres()
  
  SelectElement(Nombres(), 9) ; Sélectionne le 10ème élément
  *DeuxiemeElement = @Nombres()
  
  ; Echange le 4ème et le 10ème
  ;
  SwapElements(Nombres(), *PremierElement, *DeuxiemeElement)
    
  ; Prouvons-le
  ;
  ForEach Nombres()
    Debug Nombres()
  Next
@EndCode

@SeeAlso
  @@MoveElement

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function MoveElement(Liste(), Location [, *ElementRelatif])

@Description
  Déplace l'élément courant vers une autre 
  position dans la liste. 
  
@Parameter "Liste()"
  La liste à utiliser.

@Parameter "Location"
  L'emplacement de l'élément courant. 
  Peut être une des valeurs suivantes:
@FixedFont
  @#PB_List_First : Déplacer l'élément vers le début de la liste
  @#PB_List_Last  : Déplacer l'élément vers la fin de la liste
  @#PB_List_Before: Déplacer l'élément avant le *ElementRelatif
  @#PB_List_After : Déplacer l'élément après le *ElementRelatif
@EndFixedFont

@OptionalParameter "*ElementRelatif"
@Indent
  Indique l'adresse d'un autre élément auprès 
  duquel l'élément actuel doit être déplacé. 
  Ce paramètre est requis lorsque le paramètre 
  "Localisation" est @#PB_List_Before ou 
  @#PB_List_After. 
  Vous pouvez obtenir cette adresse en 
  utilisant l'opérateur @ avec le nom de la 
  liste.
@EndIndent
 
@NoReturnValue

@Remarks
  L'élément déplacé reste l'élément courant 
  de la liste. Cette opération est rapide 
  car la donnée elle-même n'est pas déplacée.

@Example
@Code
  NewList Nombres()
  
  For k=0 To 10
    AddElement(Nombres())
    Nombres() = k
  Next
  
  SelectElement(Nombres(), 5) 
  *Relatif = @Nombres()                             ; l'adresse de l'élément 5
  
  SelectElement(Nombres(), 0)
  MoveElement(Nombres(), #PB_List_After, *Relatif)  ; déplacement après l'élément 5
    
  SelectElement(Nombres(), 10)
  MoveElement(Nombres(), #PB_List_First)            ; déplacement au début
    
  ; Resultat
  ;
  ForEach Nombres()
    Debug Nombres()
  Next
@EndCode

@SeeAlso
  @@SwapElements

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PushListPosition(Liste())

@Description
  Mémorise l'élément courant (s'il existe) 
  afin qu'il puisse être restauré plus tard 
  en utilisant @@PopListPosition. 
  
@Parameter "Liste()"
  La liste à utiliser.

@NoReturnValue

@Remarks
  La position est mémorisée sur une structure 
  de pile, donc plusieurs appels à cette 
  fonction sont possibles.
@LineBreak
@LineBreak  
  Cette fonction peut être utilisée pour 
  sauvegarder l'élément courant, donc une 
  itération peut être faite sur la liste 
  en utilisant @@NextElement ou 
  @ReferenceLink "foreach_next" "foreach" et 
  l'élément courant peut être restauré après 
  l'itération en utilisant @@PopListPosition. 
  Plusieurs appels à cette fonction peuvent 
  être faits, aussi longtemps que chacun est 
  équilibré avec un appel @@PopListPosition 
  correspondant.
@LineBreak
@LineBreak
  Note: Il n'est pas permis de supprimer un 
  élément qui a été mémorisé, en utilisant 
  @@DeleteElement  ou @@ClearList. Cela peut 
  entraîner un plantage lors de l'appel de 
  @@PopListPosition parce que la mémoire 
  n'est plus valide. 

@Example
@Code
  NewList Nombres()
  AddElement(Nombres()): Nombres() = 1
  AddElement(Nombres()): Nombres() = 2
  AddElement(Nombres()): Nombres() = 5
  AddElement(Nombres()): Nombres() = 3
  AddElement(Nombres()): Nombres() = 5
  AddElement(Nombres()): Nombres() = 2
  
  ; Une simple élimination de doublon
  ;
  ForEach Nombres()
    Valeur = Nombres()
    PushListPosition(Nombres())
    While NextElement(Nombres())
      If Nombres() = Valeur 
        DeleteElement(Nombres())
      EndIf
    Wend
    PopListPosition(Nombres())
  Next
  
  ForEach Nombres()
    Debug Nombres()
  Next
@EndCode

@SeeAlso
  @@PopListPosition, @@SelectElement, 
  @@ChangeCurrentElement, @@NextElement, 
  @@PreviousElement, 
  @ReferenceLink "foreach_next" "ForEach"

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PopListPosition(Liste())

@Description
  Restaure l'élément courant précédemment 
  mise en mémoire avec @@PushListPosition.
  
@Parameter "Liste()"
  La liste à utiliser.

@NoReturnValue

@Remarks
  L'état de la liste sera le même que celui 
  de l'appel correspondant à 
  @@PushListPosition. S'il n'y avait pas 
  d'élément courant après un 
  @@PushListPosition alors il n'y a pas 
  d'élément courant après cet appel aussi.

@Example
@Code
  NewList Nombres()
  AddElement(Nombres()): Nombres() = 1
  AddElement(Nombres()): Nombres() = 2
  AddElement(Nombres()): Nombres() = 5
  AddElement(Nombres()): Nombres() = 3
  AddElement(Nombres()): Nombres() = 5
  AddElement(Nombres()): Nombres() = 2
  
  ; Une simple élimination de doublon
  ;
  ForEach Nombres()
    Valeur = Nombres()
    PushListPosition(Nombres())
    While NextElement(Nombres())
      If Nombres() = Valeur 
        DeleteElement(Nombres())
      EndIf
    Wend
    PopListPosition(Nombres())
  Next
  
  ForEach Nombres()
    Debug Nombres()
  Next
@EndCode

@SeeAlso
  @@PushListPosition, @@SelectElement, 
  @@ChangeCurrentElement, @@NextElement, 
  @@PreviousElement, 
  @ReferenceLink "foreach_next" "ForEach"

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function MergeLists(ListeSource(), ListeDestination() [, Location])

@Description
  Déplace tous les éléments de la liste 
  ListeSource() vers la liste 
  ListeDestination(). 

@Parameter "ListeSource()"
  La liste à partir de laquelle les éléments 
  seront pris. Cette liste sera vide après 
  l'opération.

@Parameter "ListeDestination()"
  La liste vers laquelle les éléments seront 
  déplacés. Cette liste contiendra les 
  éléments des deux listes.

@OptionalParameter "Location"
  Indique l'emplacement où les éléments 
  seront insérés  dans la liste 
  ListeDestination(). 
  Peut être une des valeurs suivantes:
@FixedFont
  @#PB_List_First : Insère les éléments au début de ListeDestination()
  @#PB_List_Last  : Ajoute des éléments à la fin de ListeDestination()
  @#PB_List_Before: Insère les éléments avant l'élément courant de ListeDestination()
  @#PB_List_After : Insère les éléments après l'élément courant de ListeDestination()
@EndFixedFont

@NoReturnValue
  
@Remarks
  Cette opération est rapide car les données 
  elles-même ne sont pas déplacées.

@Example
@Code
  NewList A.s()
  AddElement(A()): A() = "a0"
  AddElement(A()): A() = "a1"
  AddElement(A()): A() = "a2"
  AddElement(A()): A() = "a3"
  
  NewList B.s()
  AddElement(B()): B() = "b0"
  AddElement(B()): B() = "b1"
  AddElement(B()): B() = "b2"
  AddElement(B()): B() = "b3"
    
  ; Insère les éléments de A() avant l'élément "b1" de B()
  SelectElement(B(), 1)
  MergeLists(A(), B(), #PB_List_Before)
  
  ForEach B()
    Debug B()
  Next
@EndCode

@SeeAlso
  @@SplitList

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function SplitList(ListeSource(), ListeDestination() [, GarderElementCourant])

@Description
  Découpe une liste en deux.

@Parameter "ListeSource()"
  La liste à partir de laquelle les éléments 
  seront déplacés. L'élément courant de la 
  liste précise le point de division de la 
  liste. S'il n'y a pas d'élément courant, 
  alors tous les éléments restent dans 
  ListeSource().

@Parameter "ListeDestination()"
  La liste vers laquelle les éléments seront 
  déplacés. Tous les éléments existants dans 
  cette liste sont supprimés avant l'ajout 
  des nouveaux éléments.

@OptionalParameter "GarderElementCourant"
  Indique si l'élément courant de 
  ListeSource() reste dans ListeSource() ou 
  s'il est déplacé vers ListeDestination().
@FixedFont  
  @#True  : L'élément courant reste dans ListeSource(). 
  @#False : L'élément courant est déplacé vers ListeDestination() (par défaut).
@EndFixedFont

@NoReturnValue
  
@Remarks
  Cette opération est rapide car les données 
  elles-même ne sont pas déplacées.

@Remarks
  Si 'GarderElementCourant' est fixé à @#True 
  alors le nouvel élément courant dans 
  ListeSource() sera l'élément précédent de 
  la liste. S'il n'y a pas d'élément précédent 
  alors la liste n'aura plus d'élément courant. 
  La ListeDestination() n'aura aucun élément 
  courant.
   
@Example
@Code
  NewList A()
  NewList B()
  
  For i = 0 To 10
    AddElement(A())
    A() = i
  Next i
  
  ; Coupe en deux la liste A() à l'élément 5 et déplace les éléments restants dans la liste B()
  SelectElement(A(), 5)
  SplitList(A(), B())
  
  
  Debug " -- A() -- "
  ForEach A()
    Debug A()
  Next
  
  Debug " -- B() -- "
  ForEach B()
    Debug B()
  Next
@EndCode

@SeeAlso
  @@MergeLists

@SupportedOS

;--------------------------------------------------------------------------------------------------------

