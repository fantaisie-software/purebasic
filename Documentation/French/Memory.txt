;
; Memory library documentation
;
; (c) Fantaisie Software
;

@Library Memory

@Overview
  Il est parfois très utile d'avoir un accès 
  direct à la mémoire vive (RAM) de l'ordinateur 
  pour exécuter et accélérer des routines 
  gourmandes en temps d'exécution. Cette 
  bibliothèque vous permet d'allouer un 
  nombre quelconque de zones mémoire et de 
  les utiliser directement avec PureBasic.
@LineBreak
@LineBreak
  @Bold "Note:" La manipulation incorrecte 
  de zones mémoire peut conduire au plantage 
  de l'ordinateur.
  
@CommandList

@ExampleFile All MemoryBank.pb

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = AllocateMemory(Taille [, Options])

@Description
  Alloue une zone mémoire contiguë remplie 
  de zéros (caractère @#Null).
  
@Parameter "Taille"
  La taille en octets de la nouvelle zone 
  mémoire.

@OptionalParameter "Options"
  Peut être une des valeurs suivantes:
@FixedFont  
  @#PB_Memory_NoClear: Ne pas remplir la zone de mémoire avec des zéros. Cela peut aider à l'avoir plus rapidement si la mémoire allouée est utilisée immédiatement.
@EndFixedFont

@ReturnValue
  Renvoie l'adresse de la mémoire allouée 
  (@ReferenceLink "memory" "pointeur"), 
  zéro sinon.
  
@Remarks 
  La commande @@FreeMemory peut être utilisée
  pour renvoyer la mémoire allouée au système.
  @LineBreak
  La commande @@ReallocateMemory peut être 
  utilisée pour changer la taille de la zone 
  allouée.@LineBreak
  Toutes les zones de mémoire allouées sont 
  automatiquement libérées lorsque les 
  programmes se terminent.
@LineBreak
@LineBreak
   @Bold "Note:" Si le programme se bloque à 
   cette commande, c'est généralement dû à 
   une corruption de la mémoire plus tôt dans 
   le programme, après écriture, dans une 
   zone en dehors de la zone de mémoire 
   allouée.
   La cause de ce genre d'erreur peut être 
   trouvée en utilisant le
   @ReferenceLink "ide_debugtools" "purificateur 
   
@Example
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    Debug "Adresse de début de la zone mémoire de 5000 octets :"
    Debug *MemoireID
    PokeS(*MemoireID, "Stocke cette chaîne dans la zone mémoire")
    FreeMemory(*MemoireID)  ; sera également effectué automatiquement à la fin du programme
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf 
@EndCode  
  
@Example
@Code
  Texte.s = "Salut !!!"

  *mem = AllocateMemory(StringByteLength(Texte) + SizeOf(CHARACTER))
  CopyMemory(@Texte, *mem, StringByteLength(Texte) + SizeOf(CHARACTER))
  Debug MemorySize(*mem)
  Debug PeekS(*mem)
  FreeMemory(*mem)
@EndCode

@SeeAlso
  @@ReAllocateMemory, @@FreeMemory, 
  @@MemorySize

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat.Structure = AllocateStructure(Structure)

@Description
  Alloue un nouvel objet de type structure 
  dynamique.
@LineBreak
@LineBreak  
  Cette structure dynamique est correctement 
  initialisée et prête à être utilisée, sans la 
  nécessité d'appeler 
  @ReferenceLink "compilerfunctions" "InitializeStructure()".
  Pour accéder aux données de la structure, le 
  @ReferenceLink "memory" "pointeur" associé à 
  la 'Structure' spécifiée doit être utilisé.
  
@Parameter "Structure"
  Le nom de la structure utilisée pour créer 
  le nouvel objet dynamique.@LineBreak
  La structure doit exister au préalable.
  
@ReturnValue
  L'adresse (@ReferenceLink "memory" "pointeur"), 
  de la nouvelle structure dynamique, 
  zéro sinon.
  
@Remarks
  Cette commande est à la disposition des 
  utilisateurs avancés et ne devrait pas 
  être nécessaire dans la plupart des 
  programmes. Il est souvent plus judicieux 
  d'utiliser un @LibraryLink "array" "tableau" 
  structuré, une 
  @LibraryLink "list" "liste" 
  ou une @LibraryLink "map" "map" pour 
  stocker dynamiquement des objets structurés.
@LineBreak
@LineBreak
  Utiliser @@FreeStructure pour libérer la 
  mémoire d'une structure dynamique.@LineBreak
  Toutes les structures dynamiques sont 
  automatiquement libérées lorsque le 
  programme se termine.
@LineBreak
@LineBreak
  Si le programme se bloque avec cette 
  commande, c'est généralement le résultat 
  d'une corruption de la mémoire plus tôt 
  dans le programme, en écrivant dans une 
  zone à l'extérieur de la zone mémoire 
  allouée.
  Il est possible de remonter à la cause 
  de cette erreur en utilisant le 
  @ReferenceLink "ide_debugtools" "purificateur".
  
@Example
@Code
  Structure Peuple
    Nom$
    List Amis$()
  EndStructure
  
  *DynamicPeuple.Peuple = AllocateStructure(Peuple)
  *DynamicPeuple\Nom$ = "Fred"
  AddElement(*DynamicPeuple\Amis$())
  *DynamicPeuple\Amis$() = "Stef"
  
  Debug *DynamicPeuple\Nom$
  Debug *DynamicPeuple\Amis$()
  
  FreeStructure(*DynamicPeuple)
@EndCode

@SeeAlso
  @@FreeStructure

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CompareMemory(*Memoire1, *Memoire2, Taille)

@Description
  Compare deux zones mémoire.

@Parameter "*Memoire1, *Memoire2"
  Les adresses des deux mémoires à comparer.

@Parameter "Taille"
  Le nombre d'octets à comparer.

@ReturnValue
  Renvoie une valeur non nulle si les deux 
  mémoires sont identiques, zéro sinon.

@Example  
@Code
  *Memoire1 = AllocateMemory(5000)
  PokeB(*Memoire1, 65)     ; Stocke cette valeur dans la zone mémoire)
  *Memoire2 = AllocateMemory(50)
  PokeB(*Memoire2, 65) 
  *Memoire3 = AllocateMemory(100)
  PokeB(*Memoire3, 90)
    Debug CompareMemory(*Memoire1, *Memoire2, 1) ; Affiche 1
    Debug CompareMemory(*Memoire1, *Memoire3, 1) ; Affiche 0
  FreeMemory(*Memoire1) 
  FreeMemory(*Memoire2) 
  FreeMemory(*Memoire3) 
@EndCode

@SeeAlso
  @@AllocateMemory, @@CompareMemoryString, 
  @@MemorySize
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CompareMemoryString(*Texte1, *Texte2 [, Mode [, Longueur [, Options]]])

@Description
  Compare deux chaînes de caractères situées 
  en mémoire.
  
@Parameter "*Texte1, *Texte2"
  Les adresses des deux chaînes de caractères à comparer.
  
@OptionalParameter "Mode"  
  Peut prendre l'une des valeurs suivantes:
@FixedFont
  @#PB_String_CaseSensitive : La recherche est sensible à  la casse (a=a) (Par défaut).
  @#PB_String_NoCase        : Comparaison insensible à la casse (a=A).
  @#PB_String_NoCaseAscii   : Recherche insensible à la casse utilisant uniquement le jeu de caractères ascii (a=A). 
                             Beaucoup plus rapide que @#PB_String_NoCase lorsque la prise en charge complète d'Unicode n'est pas requise.
@EndFixedFont

@OptionalParameter "Longueur"
  Le nombre de caractères à comparer. 
@LineBreak
@LineBreak
  Si ce paramètre ne est pas spécifié ou égal à 
  -1 alors les chaînes sont comparées jusqu'à 
  ce qu'un caractère @#Null soit atteint.@LineBreak 
  Si les chaînes ne sont pas terminées par un 
  caractère @#Null, ce paramètre doit alors 
  être spécifié.
  
@OptionalParameter "Options"
  Peut prendre l'une des valeurs suivantes:
@FixedFont
  @#PB_Ascii  : Compare la chaîne de caractères au format ASCII
  @#PB_UTF8   : Compare la chaîne de caractères au format  UTF-8
  @#PB_Unicode: Compare la chaîne de caractères au format  Unicode
@EndFixedFont
  La valeur par défaut est @#PB_Unicode.
  
@ReturnValue  
  Renvoie l'une des valeurs suivantes:
@FixedFont
  @#PB_String_Equal  : Le 'Texte1' est égal au 'Texte2'.
  @#PB_String_Lower  : Le 'Texte1' est inférieur au 'Texte2'.
  @#PB_String_Greater: Le 'Texte1' est supérieur au 'Texte2'.
@EndFixedFont 

@Example  
@Code
  Texte1$ = "OK"
  Texte2$ = "KO"

  Comp = CompareMemoryString(@Texte1$, @Texte2$)
  Select Comp
    Case #PB_String_Equal
      Debug "Le 'Texte1' est égal au 'Texte2'."
    Case #PB_String_Lower  
      Debug "Le 'Texte1' est inférieur au 'Texte2'."
    Case #PB_String_Greater
      Debug "Le 'Texte1' est supérieur au 'Texte2'."
  EndSelect
@EndCode

@SeeAlso
  @@PokeS, @@PeekS, @@MemoryStringLength, 
  @@CopyMemoryString, @@CompareMemory, 
  @@MemorySize
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function CopyMemory(*MemoireSource, *MemoireDestination, Taille)

@Description
  Copie une zone mémoire dans une autre.
  
@Parameter "*MemoireSource"
  L'adresse de la zone mémoire à copier.
  
@Parameter "*MemoireDestination"
  L'adresse de la zone mémoire de destination.

@Parameter "Taille"
  Le nombre d'octets à copier.
 
@NoReturnValue

@Remarks
  Les zones mémoires source et destination ne 
  devraient pas se chevaucher, dans ce cas, 
  il est préférable d'utiliser @@MoveMemory.

@Example  
@Code
  Texte1$ = "OK"
  Texte2$ = "KO"
  Debug Texte1$ ; Affiche OK
  Debug Texte2$ ; Affiche KO

  CopyMemory(@Texte1$, @Texte2$, 4) ; en unicode, un caractère est codé sur 2 octets

  Debug Texte1$ ; Affiche OK
  Debug Texte2$ ; Affiche OK
@EndCode
  
@SeeAlso
  @@MoveMemory, @@CopyMemoryString, 
  @@AllocateMemory, @@MemorySize
     
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = CopyMemoryString(*Memoire [, @*MemoireDestination])

@Description
  Copie un texte d'une zone mémoire dans une 
  autre, si elle est spécifiée, à la fin du 
  tampon mémoire courant sinon.

@Parameter "*Memoire"
  L'adresse de la chaîne de caractères à copier.
@LineBreak
@LineBreak
  La chaîne doit se terminer par un caractère 
  @#Null.@LineBreak
  La chaîne doit être dans le format de chaîne 
  de PureBasic.
  
@OptionalParameter "@*MemoireDestination"  
  Le @ReferenceLink "memory" "pointeur" sur une 
  variable contenant l'adresse de la mémoire 
  tampon de destination. 
@LineBreak
@LineBreak  
  Après la copie, la variable *MemoireDestination 
  pointera vers le caractère @#Null à la fin de 
  la chaîne copiée, donc un nouvel appel à cette 
  fonction ajoutera la nouvelle chaîne à la 
  précédente.
@LineBreak
@LineBreak
   Si ce paramètre est omis, l'adresse de 
   l'appel précédent est utilisé.
  
@ReturnValue
  Renvoie *MemoireDestination.

@Example
@Code
  *Tampon = AllocateMemory(1000)
  *Pointeur = *Tampon
  CopyMemoryString("Salut", @*Pointeur)
  CopyMemoryString(" le Monde")  ; Cette chaîne sera copiée juste après "Salut"
  *Pointeur-2*SizeOf(CHARACTER)  ; revient en arrière de 2 caractères (sur le 'd' de 'Monde')
  CopyMemoryString("DE")         ; les deux dernières lettres seront en majuscules
  Debug PeekS(*Tampon)
@EndCode

@SeeAlso
  @@CopyMemory, @@PeekS, @@PokeS
    
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function FillMemory(*Memoire, Taille [, Valeur [, Type]])

@Description
  Remplit une zone mémoire avec une valeur donnée. 
  
@Parameter "*Memoire"
  L'adresse de la zone mémoire à remplir.
  
@Parameter "Taille"
  La taille en octets de la zone mémoire à 
  remplir.
  
@OptionalParameter "Valeur"
  La valeur à écrire dans la zone de mémoire. 
@Linebreak
@Linebreak   
  La valeur par défaut est la valeur @#NULL (0).

@OptionalParameter "Type"  
  Peut être une des constantes suivantes:
@FixedFont
  @#PB_Byte     : Type @ReferenceLink "variables" "byte"  (1 octet signé) (défaut).
  @#PB_Ascii    : Type @ReferenceLink "variables" "ascii" (1 octet non signé).
  @#PB_Word     : Type @ReferenceLink "variables" "word"  (2 octets signés).
  @#PB_Unicode  : Type @ReferenceLink "variables" "word"  (2 octets non signés).
  @#PB_Character: Type @ReferenceLink "variables" "caractère" (2 octets non signés en @ReferenceLink "unicode" "unicode").
  @#PB_Long     : Type @ReferenceLink "variables" "long"      (4 octets).
  @#PB_Integer  : Type @ReferenceLink "variables" "integer"   (4 octets dans un exécutable 32 bits, 8 octets dans un exécutable 64 bits).
@EndFixedFont

@NoReturnValue

@Example
@Code
  *Tampon = AllocateMemory(500)
  
  FillMemory(*Tampon, 500) ; Remplit 500 octets avec des zéros (vide la zone mémoire)
  FillMemory(*Tampon, 500, $FF) ; Remplit 500 octets avec la valeur $FF
  FillMemory(*Tampon, 500, $BADF00D, #PB_Long) ; Remplit 500 octets avec la valeur $BADF00D
@EndCode

@SeeAlso
  @@AllocateMemory, @@MemorySize
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function FreeMemory(*Memoire)

@Description
  Libère une zone mémoire.
  
@Parameter "*Memoire"
  L'adresse de la zone de mémoire à libérer.
@LineBreak
@LineBreak
  Ce doit être la valeur renvoyée par 
  @@AllocateMemory ou @@ReAllocateMemory. 
 
@NoReturnValue

@Remarks
  Si le programme se bloque à cette commande, 
  même si l'entrée semble correcte, c'est 
  généralement le résultat d'une corruption de 
  mémoire à un moment plus tôt dans le programme 
  en écrivant dans une zone à l'extérieur de la 
  zone de mémoire allouée.
  Une telle erreur peut être analysée en utilisant le 
  @ReferenceLink "ide_debugtools" "purificateur" 
@LineBreak  
@LineBreak
  Toutes les zones mémoire restantes sont 
  automatiquement libérées quand le programme 
  se termine.  
   
@Example
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    Debug "Adresse de début de la zone mémoire de 5000 octets :"
    Debug *MemoireID
    PokeS(*MemoireID, "Stocke cette chaîne dans la zone mémoire")
    FreeMemory(*MemoireID)  ; sera également effectué automatiquement à la fin du programme
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf 
@EndCode  

@SeeAlso
  @@AllocateMemory, @@ReAllocateMemory
    
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function FreeStructure(*Structure)

@Description
  Libère la structure dynamique précédemment 
  allouée avec @@AllocateStructure. 

@Parameter "*Structure"
  L'adresse de la structure dynamique à 
  libérer. 
@LineBreak
@LineBreak  
  Ce doit être la valeur renvoyée 
  par @@AllocateStructure.
  
@NoReturnValue

@Remarks
  Il n'est pas nécessaire d'appeler 
  @ReferenceLink "compilerfunctions" "ClearStructure()" 
  avant de libérer la structure.
@LineBreak
@LineBreak 
  Si le programme se bloque avec cette commande, 
  c'est généralement le résultat d'une corruption 
  de la mémoire plus tôt dans le programme, en 
  écrivant dans une zone à l'extérieur de la 
  zone mémoire allouée.
  Il est possible de remonter à la cause de cette 
  erreur en utilisant le 
  @ReferenceLink "ide_debugtools" "purificateur". 
@LineBreak
@LineBreak
  Toutes les structures dynamiques sont 
  automatiquement libérées à la fermeture 
  du programme.
  
@Example
@Code
  Structure Peuple
    Nom$
    List Amis$()
  EndStructure
  
  *DynamicPeuple.Peuple = AllocateStructure(Peuple)
  *DynamicPeuple\Nom$ = "Fred"
  AddElement(*DynamicPeuple\Amis$())
  *DynamicPeuple\Amis$() = "Stef"
  
  Debug *DynamicPeuple\Nom$
  Debug *DynamicPeuple\Amis$()
  
  FreeStructure(*DynamicPeuple)
@EndCode
  
@SeeAlso
  @@AllocateStructure
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = MemorySize(*Memoire)

@Description
  Renvoie la taille d'une zone mémoire.
  
@Parameter "*Memoire"
  L'adresse de la zone mémoire à utiliser. 
@LineBreak
@LineBreak
  Ce doit être la valeur renvoyée par 
  @@AllocateMemory ou @@ReAllocateMemory. 

@ReturnValue
  Renvoie la taille de la zone mémoire, en octets.
  
@Example
@Code
  Texte1$="OK"
  *Mem=AllocateMemory(100)
  ;Debug MemorySize(@Texte1$) ; Erreur
  Debug MemorySize(*Mem) ; Affiche 100
@EndCode
  
@Example
@Code
  Texte.s = "Salut !!!"

  *mem = AllocateMemory(StringByteLength(Texte) + SizeOf(CHARACTER))
  CopyMemory(@Texte, *mem, StringByteLength(Texte) + SizeOf(CHARACTER))
  Debug MemorySize(*mem)
  Debug PeekS(*mem)
  FreeMemory(*mem)
@EndCode
    
@SeeAlso
  @@AllocateMemory, @@ReAllocateMemory, 
  @@FreeMemory
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = MemoryStringLength(*Memoire [, Options])

@Description
  Renvoie la longueur d'une chaîne de caractères
  en mémoire et terminée par un caractère @#Null. 
  
@Parameter "*Memoire"
  L'adresse de la chaîne de caractères.

@OptionalParameter "Options"
  Le format à utiliser.@LineBreak 
  Peut prendre l'une des valeurs suivantes:
@FixedFont
  @#PB_Ascii  : Format ASCII
  @#PB_UTF8   : Format UTF-8 
  @#PB_Unicode: Format Unicode (par défaut, voir @ReferenceLink "unicode" "unicode")
@EndFixedFont
    Combiné avec l'une des valeurs suivantes:
@FixedFont
  @#PB_ByteLength: Seulement avec l'option @#PB_UTF8, le résultat représentera des octets (pas des caractères).
                  Cela peut être utile car UTF8 a des caractères de longueur variable.
@EndFixedFont
  
@ReturnValue
  Renvoie la longueur de la chaîne de caractères, 
  en caractères excepté le caractère @#Null de 
  fin de chaîne.
 
@Example
@Code
  Texte1$ = "OK"
  Debug MemoryStringLength(@Texte1$) ; Affiche 2
@EndCode
  
@SeeAlso
  @@PokeS, @@PeekS, @@AllocateMemory
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function MoveMemory(*MemoireSource, *MemoireDestination, Taille)

@Description
  Copie une zone mémoire dans une autre.@LineBreak
  Le chevauchement des deux zones mémoire est 
  autorisé.
  
@Parameter "*MemoireSource"
  L'adresse de la zone mémoire à copier.
  
@Parameter "*MemoireDestination"
  L'adresse de la zone mémoire de destination.

@Parameter "Taille"
  Le nombre d'octets à copier.

@NoReturnValue

@Remarks
  Contrairement à @@CopyMemory, les zones mémoires 
  source et destination peuvent se chevaucher. 
  Néanmoins, MoveMemory() est plus lent que 
  @@CopyMemory, donc il est préférable de 
  l'utiliser que si c'est justifié.

@Example  
@Code
  Texte1$ = "OK"
  Texte2$ = "KOKO"
  Debug Texte1$ ; Affiche OK
  Debug Texte2$ ; Affiche KOKO

  MoveMemory(@Texte1$, @Texte2$ + 4, 4) ; en unicode, un caractère est codé sur 2 octets

  Debug Texte1$ ; Affiche OK
  Debug Texte2$ ; Affiche KOOK
@EndCode
  
@SeeAlso
  @@CopyMemory, @@AllocateMemory, @@MemorySize
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function *Resultat = ReAllocateMemory(*Memoire, Taille [, Options])

@Description
  Redimensionne une zone mémoire.
  
@Parameter "*Memoire"
  L'adresse de la zone mémoire à redimensionner.
  @LineBreak
   Cette valeur doit être le résultat d'un 
   appel à @@AllocateMemory ou à 
   @@ReAllocateMemory.
@LineBreak
@LineBreak 
   Si ce paramètre est @#Null, la commande agit
   comme @@AllocateMemory et alloue une zone 
   mémoire mais avec la nouvelle dimension.
 
@Parameter "Taille"
  La nouvelle taille en octets.
  
@OptionalParameter "Options"
@FixedFont  
  @#PB_Memory_NoClear: Ne remplit pas la zone mémoire étendue avec des zéros. Cela peut aider à l'avoir plus rapidement si la mémoire 
                      étendue est utilisée immédiatement. Si la mémoire est rétrécie, cette option n'a aucun effet.
@EndFixedFont 

@ReturnValue
  Renvoie la nouvelle adresse de la zone mémoire 
  si elle peut être redimensionnée. Dans ce cas, 
  l'ancienne adresse '*MemoireID' ne peut plus 
  être utilisée. Si le redimensionnement a échoué
  (car il n'y a pas assez de mémoire disponible),  
  le résultat est égal à zéro et le '*Memoire' 
  est toujours valide avec la zone de mémoire 
  existante et l'ancienne taille.

@Remarks
  Si la taille de la zone de mémoire est 
  augmentée, les nouveaux octets sont tout 
  d'abord remplis de zéros à moins que 
  @#PB_Memory_NoClear ne soit indiqué. 
@LineBreak
@LineBreak
  Si le programme se bloque à cette commande, 
  même si l'entrée semble correcte, c'est 
  généralement le résultat d'une altération de 
  la mémoire qui s'est produite antérieurement 
  dans le programme par l'écriture dans une zone 
  à l'extérieur de la zone de mémoire allouée.
  Il est possible de trouver la cause de ce genre 
  d'erreur en utilisant le 
  @ReferenceLink "ide_debugtools" "purificateur"
@LineBreak
@LineBreak
  Tous les blocs de mémoire alloués restants sont 
  automatiquement libérés lorsque le programme 
  se termine.
  
@Example
@Code
  *MemoireID = AllocateMemory(1000)
  PokeS(*MemoireID, "Stocke cette chaîne")
  ; faire quelque chose en plus avec ça ici...
  ;
  *NouvelleMemoireID = ReAllocateMemory(*MemoireID, 2000) ; besoin de plus de mémoire
  If *NouvelleMemoireID
    ; maintenant travailler avec *NouvelleMemoireID avec une taille de 2000 octets
    Debug "L'ancien contenu est toujours là :"
    Debug PeekS(*NouvelleMemoireID)
    ;
    FreeMemory(*NouvelleMemoireID)
  Else
    ; le redimensionnement a échoué, continuons de travailler avec *MemoireID (de taille 1000 octets)
    ;
    FreeMemory(*MemoireID)
  EndIf
@EndCode

@SeeAlso
  @@AllocateMemory, @@FreeMemory, @@MemorySize
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.a = PeekA(*Memoire)

@Description
  Lit un caractère ascii en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du caractère 
  @ReferenceLink "variables" "ascii".@LineBreak
  Vous trouverez une table ASCII 
  @ReferenceLink "ascii" "ici".

@Remarks
  Représente 1 octet non signé de 0 à + 255.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeA(*MemoireID, 65)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekA(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    Debug Chr(PeekA(*MemoireID))
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode
  
@SeeAlso
  @@PokeA
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.b = PeekB(*Memoire)

@Description
  Lit un octet (byte) en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur de l' 
  @ReferenceLink "variables" "octet".

@Remarks
  Reprsente 1 octet signé de -128 à +127.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeB(*MemoireID, 65)     ; Stocke cette valeur dans la zone mémoire")
    Debug PeekB(*MemoireID)   ; Lit cette valeur depuis la zone mémoire")
    PokeB(*MemoireID+1, -65)   
    Debug PeekB(*MemoireID + 1)
    Debug ~65+1                ; Complément à 2
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeB
     
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.c = PeekC(*Memoire)

@Description
  Lit un caractère en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du 
  @ReferenceLink "variables" "caractère".

@Remarks
  Représente 2 octets non signés de 0 à +65 535 en 
  mode unicode.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeC(*MemoireID, 65)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekC(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    Debug Chr(PeekC(*MemoireID))
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeC
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.d = PeekD(*Memoire)

@Description
  Lit un double en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du 
  @ReferenceLink "variables" "double".

@Remarks
  Représente 8 octets représentant un nombre 
  à virgule flottante en double précision.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeD(*MemoireID, 123456789.123456789) ; Stocke cette valeur dans la zone mémoire")
    Debug PeekD(*MemoireID)                ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeD
   
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.i = PeekI(*Memoire)

@Description
  Lit un entier 'integer' en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur de l' 
  @ReferenceLink "variables" "integer".

@Remarks
  Représente 4 octets signés de -2 147 483 648 à 
  + 2 147 483 647 sur un exécutable 32 bits, 
  8 octets signés de -9 223 372 036 854 775 808 
  à + 9 223 372 036 854 775 807 sur un exécutable
  64 bits.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeI(*MemoireID, 123456789.123456789)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekI(*MemoireID)                  ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeI
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.l = PeekL(*Memoire)

@Description
  Lit un long en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur de l' 
  @ReferenceLink "variables" "octet".

@Remarks
  Représente 4 octets signé de -2 147 483 648 à 
  + 2 147 483 647.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeL(*MemoireID, 123456789) ; Stocke cette valeur dans la zone mémoire")
    Debug PeekL(*MemoireID)      ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeL
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.w = PeekW(*Memoire)

@Description
  Lit un mot (word) en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du 
  @ReferenceLink "variables" "mot".

@Remarks
  Représente 2 octets signés de -32 768 à +32 767.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeW(*MemoireID, 32000)     ; Stocke cette valeur dans la zone mémoire")
    Debug PeekW(*MemoireID)      ; Lit cette valeur depuis la zone mémoire")
    PokeW(*MemoireID+2, -32000)  
    Debug PeekW(*MemoireID+2)
    Debug ~32000+1               ; Complément à deux
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode
@SeeAlso
  @@PokeW
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.f = PeekF(*Memoire)

@Description
  Lit un float en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du 
  @ReferenceLink "variables" "float".

@Remarks
  Représente 4 octets représentant un nombre 
  à virgule flottante en simple précision.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeF(*MemoireID, 12345.12345)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekF(*MemoireID)          ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode
@SeeAlso
  @@PokeF
   
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.q = PeekQ(*Memoire)

@Description
  Lit un quad en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du 
  @ReferenceLink "variables" "quad".

@Remarks
  Représente 8 octets signés de -9 223 372 036 854 775 808 
  à + 9 223 372 036 854 775 807.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeQ(*MemoireID, 1234567890123456789)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekQ(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat$ = PeekS(*Memoire [, Longueur [, Format]])

@Description
  Lit une chaîne de caractères en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur de la 
  @ReferenceLink "variables" "chaîne de caractères".

@OptionalParameter "Longueur"  
  Le nombre maximum de caractères à lire. 
  @LineBreak 
  Si ce paramètre n'est pas spécifié ou s'il 
  est égal à -1, il n'y a pas de maximum.
  @LineBreak 
  La chaîne est lue jusqu'a ce que le caractère 
  @#NULL soit rencontré ou si la longueur 
  maximale est atteinte.
  
@OptionalParameter "Format"  
  Le format à utiliser.@LineBreak 
  Peut prendre l'une des valeurs suivantes:
@FixedFont
  @#PB_Ascii  : Format ASCII 
  @#PB_UTF8   : Format UTF-8 
  @#PB_Unicode: Format Unicode (par défaut)
@EndFixedFont
    Combiné avec l'une des valeurs suivantes:
@FixedFont
  @#PB_ByteLength: Seulement avec l'option @#PB_UTF8, le résultat représentera des octets (pas des caractères).
                  Cela peut être utile car UTF8 a des caractères de longueur variable.
@EndFixedFont

@ReturnValue
  Renvoie la chaîne lue.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeS(*MemoireID, "PureBasic hé")   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekS(*MemoireID)             ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode
@SeeAlso
  @@PokeS, @@MemoryStringLength, 
  @@CompareMemoryString, @@CopyMemoryString
   
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat.u = PeekU(*Memoire)

@Description
  Lit un caractère unicode en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire à lire.

@ReturnValue
  Renvoie la valeur du caractère 
  @ReferenceLink "variables" "unicode".

@Remarks
  Représente 2 octets non signés de 0 à + 65 535.
   
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeU(*MemoireID, 165)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekU(*MemoireID)  ; Lit cette valeur depuis la zone mémoire")
    Debug Chr(PeekU(*MemoireID))
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PokeU
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeA(*Memoire, Valeur.a)

@Description 
  Ecrit un caractère ascii en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.a"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 1 octet non signé de 0 à + 255.@LineBreak
  Vous trouverez une table ASCII 
  @ReferenceLink "ascii" "ici".
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeA(*MemoireID, 65)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekA(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekA
     
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeB(*Memoire, Valeur.b)

@Description 
  Ecrit un octet (byte) en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.b"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 1 octet signé de -128 à +127. 
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeB(*MemoireID, 65)     ; Stocke cette valeur dans la zone mémoire")
    Debug PeekB(*MemoireID)   ; Lit cette valeur depuis la zone mémoire")
    PokeB(*MemoireID+1, -65)   
    Debug PeekB(*MemoireID+1)
    Debug ~65+1               ; Complément à 2
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekB
    
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeC(*Memoire, Valeur.c)

@Description 
  Ecrit un caractère en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.c"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 2 octets non signés de 0 à +65 535 en 
  mode unicode.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeC(*MemoireID, 65)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekC(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    Debug Chr(PeekC(*MemoireID))
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@Remarks
  Représente 8 octets représentant un nombre 
  à virgule flottante en double précision.
  
@SeeAlso
  @@PeekC
  
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeD(*Memoire, Valeur.d)

@Description 
  Ecrit un double en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeurd."
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 8 octets représentant un nombre 
  à virgule flottante en double précision.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeD(*MemoireID, 123456789.123456789)     ; Stocke cette valeur dans la zone mémoire")
    Debug PeekD(*MemoireID)                ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekD
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeI(*Memoire, Valeur.i)

@Description
  Ecrit un entier (integer) en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.i"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 4 octets signés de -2 147 483 648 à 
  + 2 147 483 647 sur un exécutable 32 bits, 
  8 octets signés de -9 223 372 036 854 775 808 
  à + 9 223 372 036 854 775 807 sur un exécutable
  64 bits.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeI(*MemoireID, 123456789.123456789)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekI(*MemoireID)                  ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekI
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeL(*Memoire, Valeur.l)

@Description 
  Ecrit un long en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.l"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 4 octets signé de -2 147 483 648 à 
  + 2 147 483 647.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeL(*MemoireID, 123456789)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekL(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekL
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeQ(*Memoire, Valeur.q)

@Description 
  Ecrit un quad en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.q"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 8 octets signés de -9 223 372 036 854 775 808 
  à + 9 223 372 036 854 775 807.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeQ(*MemoireID, 1234567890123456789)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekQ(*MemoireID) ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekQ
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeW(*Memoire, Valeur.w)

@Description 
  Ecrit un mot (word) en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.w"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 2 octets signés de -32 768 à +32 767.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeW(*MemoireID, 32000)     ; Stocke cette valeur dans la zone mémoire")
    Debug PeekW(*MemoireID)      ; Lit cette valeur depuis la zone mémoire")
    PokeW(*MemoireID+2, -32000)  
    Debug PeekW(*MemoireID+2)
    Debug ~32000+1              ; Complément à deux
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekW  

@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeF(*Memoire, Valeur.f)

@Description 
  Ecrit un float en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.f"
  La valeur à écrire.
  
@NoReturnValue

@Remarks
  Représente 4 octets représentant un nombre 
  à virgule flottante en simple précision.

@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeF(*MemoireID, 12345.12345)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekF(*MemoireID)          ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekF
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function Resultat = PokeS(*Memoire, Texte$ [, Longueur [, Options]])

@Description
  Ecrit une chaîne de caractères, suivi d'un
  caractère @#NULL de fin de chaîne en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Texte$"
  La chaîne de caractères à écrire.
  
@OptionalParameter "Longueur"  
  Longueur maximale (en caractères).
@LineBreak
@LineBreak
  Si ce paramètre n'est pas spécifié ou égal 
  à -1 alors toute la chaîne est écrite.@LineBreak
  Le caractère @#NULL de fin de chaîne qui est 
  toujours écrit (sauf si @#PB_String_NoZero 
  est défini) n'est pas inclus dans ce décompte.
  
@OptionalParameter "Options" 
  Peut prendre l'une des valeurs suivantes:
@FixedFont
  @#PB_Ascii  : Format ASCII
  @#PB_UTF8   : Format UTF-8
  @#PB_Unicode: Format Unicode (Par défaut)
  Combiné avec
  @#PB_String_NoZero: N'écrit pas le caractère @#NULL de fin de chaîne.
@EndFixedFont

@ReturnValue
  Renvoie le nombre d'octets écrits, non compris 
  le caractère @#NULL de fin de chaîne.@LineBreak
  Le nombre d'octets écrit diffère de la 
  longueur de la chaîne en caractères si le 
  format est @#PB_UTF8 ou @#PB_Unicode.
  
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeS(*MemoireID, "PureBasic hé")   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekS(*MemoireID)             ; Lit cette valeur depuis la zone mémoire")
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekS, @@CopyMemoryString
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------

@Function PokeU(*Memoire, Valeur.u)

@Description 
  Ecrit un caractère unicode en mémoire.

@Parameter "*Memoire"
  L'adresse mémoire où écrire.

@Parameter "Valeur.u"
  La valeur à écrire.
  
@NoReturnValue
   
@Example  
@Code
  *MemoireID = AllocateMemory(5000)
  If *MemoireID
    PokeU(*MemoireID, 165)   ; Stocke cette valeur dans la zone mémoire")
    Debug PeekU(*MemoireID)  ; Lit cette valeur depuis la zone mémoire")
    Debug Chr(PeekU(*MemoireID))
    FreeMemory(*MemoireID)  
  Else
    Debug "Impossible d'allouer la mémoire demandée !"
  EndIf
@EndCode

@SeeAlso
  @@PeekU
 
@SupportedOS

;--------------------------------------------------------------------------------------------------------
